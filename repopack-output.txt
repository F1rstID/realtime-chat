This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-24T09:50:46.148Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    cd.yaml
application/
  usecase/
    auth_usecase.go
    chat_usecase.go
    message_usecase.go
common/
  response.go
config/
  config.go
docs/
  docs.go
  swagger.json
  swagger.yaml
domain/
  dto/
    message_dto.go
  events/
    websocket_events.go
  models/
    chat_group.go
    chat.go
    message.go
    user.go
  repositories/
    chat_repository.go
    message_repository.go
    user_repository.go
  services/
    auth_service.go
    chat_service.go
infrastructure/
  logger/
    logger.go
  sqlite/
    initialize.go
  websocket/
    hub.go
interfaces/
  controllers/
    auth_controller.go
    chat_controller.go
    message_controller.go
    websocket_controller.go
  middlewares/
    auth_middleware.go
    error_handler.go
    request_logger.go
    websocket_middleware.go
  repositories/
    chat_repository.go
    message_repository.go
    user_repository.go
  routers/
    router.go
  errors.go
  response.go
.gitignore
Dockerfile
go.mod
go.sum
main.go
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/cd.yaml
================
name: ci-pipeline

on:
  push:
    branches:
      - main
    paths-ignore:  # 불필요한 빌드 방지
      - '**.md'
      - '.gitignore'
      - 'LICENSE'

jobs:
  ci-cd:  # 단일 job으로 통합하여 중복 설정 제거
    runs-on: ubuntu-latest
    steps:
      - name: Cache Docker layers  # 도커 레이어 캐싱 추가
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          buildkitd-flags: --debug  # 빌드 성능 향상

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/realtime-chat:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          platforms: linux/amd64  # 필요한 플랫폼만 지정
          build-args: |  # 빌드 최적화를 위한 인자 추가
            BUILDKIT_INLINE_CACHE=1

      - name: Move cache  # 캐시 정리
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ec2-user
          key: ${{ secrets.PRIVATE_KEY }}
          port: 22
          script: |
            docker-compose pull
            docker-compose up -d --remove-orphans
            docker image prune -f  # 사용하지 않는 이미지 정리

================
File: application/usecase/auth_usecase.go
================
// application/usecase/auth_usecase.go

package usecase

import (
	"errors"
	"strings"
	"time"

	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/f1rstid/realtime-chat/domain/repositories"
	"github.com/f1rstid/realtime-chat/domain/services"
)

// RegisterInput defines the input data for registration
type RegisterInput struct {
	Email    string `json:"email" validate:"required,email"`
	Nickname string `json:"nickname" validate:"required,min=2,max=20"`
	Password string `json:"password" validate:"required,min=8"`
}

// LoginInput defines the input data for login
type LoginInput struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}

// AuthResponse defines the response data for authentication operations
type AuthResponse struct {
	Token string      `json:"token"`
	User  interface{} `json:"user"`
}

type AuthUsecase struct {
	userRepo    repositories.UserRepository
	authService services.AuthService
}

func NewAuthUsecase(userRepo repositories.UserRepository, authService services.AuthService) *AuthUsecase {
	return &AuthUsecase{
		userRepo:    userRepo,
		authService: authService,
	}
}

func (au *AuthUsecase) Register(input RegisterInput) (*AuthResponse, error) {
	// Clean input
	input.Email = strings.TrimSpace(strings.ToLower(input.Email))
	input.Nickname = strings.TrimSpace(input.Nickname)

	// Create user model
	user := &models.User{
		Email:     input.Email,
		Nickname:  input.Nickname,
		Password:  input.Password,
		CreatedAt: time.Now(),
	}

	// Check if email exists
	existingUser, err := au.userRepo.FindByEmail(input.Email)
	if err == nil && existingUser != nil {
		return nil, errors.New("email already exists")
	}

	// Check if nickname exists
	existingUser, err = au.userRepo.FindByNickname(input.Nickname)
	if err == nil && existingUser != nil {
		return nil, errors.New("nickname already exists")
	}

	// Hash password
	hashedPassword, err := au.authService.HashPassword(input.Password)
	if err != nil {
		return nil, err
	}
	user.Password = hashedPassword

	// Create user
	createdUser, err := au.userRepo.Create(user)
	if err != nil {
		return nil, err
	}

	// Generate token
	token, err := au.authService.GenerateToken(createdUser)
	if err != nil {
		return nil, err
	}

	return &AuthResponse{
		Token: token,
		User:  createdUser,
	}, nil
}

func (au *AuthUsecase) Login(input LoginInput) (*AuthResponse, error) {
	// Clean input
	input.Email = strings.TrimSpace(strings.ToLower(input.Email))

	// Find user by email
	user, err := au.userRepo.FindByEmail(input.Email)
	if err != nil {
		return nil, errors.New("invalid email or password")
	}

	// Check password
	err = au.authService.ComparePassword(user.Password, input.Password)
	if err != nil {
		return nil, errors.New("invalid email or password")
	}

	// Generate token
	token, err := au.authService.GenerateToken(user)
	if err != nil {
		return nil, err
	}

	return &AuthResponse{
		Token: token,
		User:  user,
	}, nil
}

================
File: application/usecase/chat_usecase.go
================
package usecase

import (
	"errors"
	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/f1rstid/realtime-chat/domain/repositories"
)

type ChatUsecase struct {
	chatRepo    repositories.ChatRepository
	messageRepo repositories.MessageRepository
	userRepo    repositories.UserRepository
}

func NewChatUsecase(
	chatRepo repositories.ChatRepository,
	messageRepo repositories.MessageRepository,
	userRepo repositories.UserRepository,
) *ChatUsecase {
	return &ChatUsecase{
		chatRepo:    chatRepo,
		messageRepo: messageRepo,
		userRepo:    userRepo,
	}
}

// CreatePrivateChat creates a 1:1 chat between two users
func (cu *ChatUsecase) CreatePrivateChat(user1ID, user2ID int) (*models.Chat, error) {
	// Verify both users exist
	user1, err := cu.userRepo.FindByID(user1ID)
	if err != nil {
		return nil, errors.New("user1 not found")
	}

	user2, err := cu.userRepo.FindByID(user2ID)
	if err != nil {
		return nil, errors.New("user2 not found")
	}

	chat := &models.Chat{
		Name: user1.Nickname + "-" + user2.Nickname,
	}

	if err := cu.chatRepo.Create(chat); err != nil {
		return nil, err
	}

	if err := cu.chatRepo.AddUserToChat(chat.ID, user1ID); err != nil {
		cu.chatRepo.Delete(chat.ID)
		return nil, errors.New("failed to add user1 to chat")
	}

	if err := cu.chatRepo.AddUserToChat(chat.ID, user2ID); err != nil {
		cu.chatRepo.Delete(chat.ID)
		return nil, errors.New("failed to add user2 to chat")
	}
	return chat, nil
}

func (cu *ChatUsecase) CreateGroupChat(name string, userIDs []int) (*models.Chat, error) {
	// Verify all users exist
	for _, userID := range userIDs {
		_, err := cu.userRepo.FindByID(userID)
		if err != nil {
			return nil, errors.New("user not found: " + string(userID))
		}
	}

	chat := &models.Chat{
		Name: name,
	}

	if err := cu.chatRepo.Create(chat); err != nil {
		return nil, err
	}

	// Add users to the chat group
	for _, userID := range userIDs {
		if err := cu.chatRepo.AddUserToChat(chat.ID, userID); err != nil {
			// If there's an error, we might want to clean up the created chat
			cu.chatRepo.Delete(chat.ID)
			return nil, errors.New("failed to add user to chat group")
		}
	}

	return chat, nil
}

// GetUserChats returns all chats for a user
func (cu *ChatUsecase) GetUserChats(userID int) ([]models.Chat, error) {
	
	return nil, nil
}

================
File: application/usecase/message_usecase.go
================
// application/usecase/message_usecase.go

package usecase

import (
	"errors"
	"time"

	"github.com/f1rstid/realtime-chat/domain/dto"
	"github.com/f1rstid/realtime-chat/domain/events"
	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/f1rstid/realtime-chat/domain/repositories"
	"github.com/f1rstid/realtime-chat/infrastructure/logger"
	"github.com/f1rstid/realtime-chat/infrastructure/websocket"
)

type MessageUsecase struct {
	messageRepo repositories.MessageRepository
	chatRepo    repositories.ChatRepository
	wsHub       *websocket.Hub
}

func NewMessageUsecase(
	messageRepo repositories.MessageRepository,
	chatRepo repositories.ChatRepository,
	wsHub *websocket.Hub,
) *MessageUsecase {
	return &MessageUsecase{
		messageRepo: messageRepo,
		chatRepo:    chatRepo,
		wsHub:       wsHub,
	}
}

// SendMessage sends a new message in a chat
func (mu *MessageUsecase) SendMessage(chatID, senderID int, content string) (*dto.MessageResponse, error) {
	// Verify chat exists
	chat, err := mu.chatRepo.FindById(chatID)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	message := &models.Message{
		ChatId:    chat.ID,
		SenderId:  senderID,
		Content:   content,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	if err := mu.messageRepo.Create(message); err != nil {
		logger.Error("Failed to create message: %v", err)
		return nil, err
	}

	// Create and broadcast WebSocket event with unified response format
	eventData := &events.MessageEventData{
		MessageID:      message.ID,
		ChatID:         message.ChatId,
		SenderID:       message.SenderId,
		SenderNickname: message.SenderNickname,
		Content:        message.Content,
		CreatedAt:      message.CreatedAt,
		UpdatedAt:      message.UpdatedAt,
	}

	event := events.NewWebSocketEvent(events.EventMessageCreated, chatID, eventData)
	if eventJSON, err := event.ToJSON(); err == nil {
		mu.wsHub.BroadcastToChat(chatID, eventJSON)
	}

	return dto.NewMessageResponse(message), nil
}

// UpdateMessage updates an existing message
func (mu *MessageUsecase) UpdateMessage(messageID, userID int, newContent string) (*dto.MessageResponse, error) {
	// Get original message
	originalMessage, err := mu.messageRepo.FindById(messageID)
	if err != nil {
		return nil, errors.New("message not found")
	}

	if originalMessage.SenderId != userID {
		return nil, errors.New("unauthorized to update this message")
	}

	// Update message
	updatedMessage := &models.Message{
		ID:        originalMessage.ID,
		ChatId:    originalMessage.ChatId,
		SenderId:  originalMessage.SenderId,
		Content:   newContent,
		CreatedAt: originalMessage.CreatedAt,
		UpdatedAt: time.Now(),
	}

	if err := mu.messageRepo.Update(updatedMessage); err != nil {
		return nil, err
	}

	// Create and broadcast WebSocket event with unified response format
	eventData := &events.MessageEventData{
		MessageID:      updatedMessage.ID,
		ChatID:         updatedMessage.ChatId,
		SenderID:       updatedMessage.SenderId,
		SenderNickname: updatedMessage.SenderNickname,
		Content:        updatedMessage.Content,
		CreatedAt:      updatedMessage.CreatedAt,
		UpdatedAt:      updatedMessage.UpdatedAt,
	}

	event := events.NewWebSocketEvent(events.EventMessageUpdated, updatedMessage.ChatId, eventData)
	if eventJSON, err := event.ToJSON(); err == nil {
		mu.wsHub.BroadcastToChat(updatedMessage.ChatId, eventJSON)
	}

	return dto.NewMessageResponse(updatedMessage), nil
}

// DeleteMessage deletes an existing message
func (mu *MessageUsecase) DeleteMessage(messageID, userID int) error {
	message, err := mu.messageRepo.FindById(messageID)
	if err != nil {
		return errors.New("message not found")
	}

	if message.SenderId != userID {
		return errors.New("unauthorized to delete this message")
	}

	if err := mu.messageRepo.Delete(messageID); err != nil {
		return err
	}

	// Create and broadcast WebSocket event with unified response format
	eventData := &events.MessageEventData{
		MessageID:      message.ID,
		ChatID:         message.ChatId,
		SenderID:       message.SenderId,
		SenderNickname: message.SenderNickname,
		CreatedAt:      message.CreatedAt,
		UpdatedAt:      time.Now(),
	}

	event := events.NewWebSocketEvent(events.EventMessageDeleted, message.ChatId, eventData)
	if eventJSON, err := event.ToJSON(); err == nil {
		mu.wsHub.BroadcastToChat(message.ChatId, eventJSON)
	}

	return nil
}

// GetChatMessages retrieves messages for a chat with cursor-based pagination
func (mu *MessageUsecase) GetChatMessages(chatId int, cursor int) (*dto.ChatMessagesResponse, error) {
	// Verify chat exists
	chat, err := mu.chatRepo.FindById(chatId)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	// Get messages
	messages, err := mu.messageRepo.FindByChatId(chatId, cursor, 50)
	if err != nil {
		return nil, err
	}

	// Get last message ID for the first page
	var lastMessageId int
	if cursor == 0 {
		lastMessageId, err = mu.messageRepo.GetLastMessageId(chatId)
		if err != nil {
			return nil, err
		}
	}

	// Create response
	response := &dto.ChatMessagesResponse{
		ChatId:        chat.ID,
		Messages:      dto.NewMessageResponseList(messages),
		LastMessageId: lastMessageId,
		HasMore:       len(messages) == 50,
		NextCursor:    0,
	}

	// Set next cursor if there are more messages
	if len(messages) > 0 {
		response.NextCursor = messages[len(messages)-1].ID
	}

	return response, nil
}

================
File: common/response.go
================
// common/response.go
package common

// Response codes
const (
	// Success codes (2xxx)
	StatusSuccess = 2000
	StatusCreated = 2001

	// Client errors (4xxx)
	StatusInvalidRequest  = 4000
	StatusUnauthorized    = 4001
	StatusForbidden       = 4002
	StatusNotFound        = 4003
	StatusEmailExists     = 4004
	StatusNicknameExists  = 4005
	StatusInvalidAuth     = 4006
	StatusChatNotFound    = 4007
	StatusMessageNotFound = 4008
	StatusUnauthorizedMsg = 4009

	// Server errors (5xxx)
	StatusInternalError = 5000
	StatusDatabaseError = 5001
)

// BaseResponse 기본 응답 구조
type BaseResponse struct {
	Success bool        `json:"success" example:"true"`
	Code    int         `json:"code" example:"2000"`
	Data    interface{} `json:"data"`
}

// ErrorResponse 에러 응답 예시용 구조체
type ErrorResponse struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4000"`
	Data    string `json:"data" example:"잘못된 요청입니다"`
}

// AuthData represents authentication data
type AuthData struct {
	Token string   `json:"token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
	User  UserData `json:"user"`
}

// UserData represents user information
type UserData struct {
	ID        int    `json:"id" example:"1"`
	Email     string `json:"email" example:"user@example.com"`
	Nickname  string `json:"nickname" example:"홍길동"`
	CreatedAt string `json:"createdAt" example:"2024-03-23T12:00:00Z"`
}

// ChatData represents chat information
type ChatData struct {
	ID        int    `json:"id" example:"1"`
	Name      string `json:"name" example:"개발팀 채팅방"`
	CreatedAt string `json:"createdAt" example:"2024-03-23T12:00:00Z"`
}

// MessageData represents message information
type MessageData struct {
	ID             int    `json:"id" example:"1"`
	ChatID         int    `json:"chatId" example:"1"`
	SenderID       int    `json:"senderId" example:"1"`
	SenderNickname string `json:"senderNickname" example:"홍길동"`
	Content        string `json:"content" example:"안녕하세요"`
	CreatedAt      string `json:"createdAt" example:"2024-03-23T12:00:00Z"`
	UpdatedAt      string `json:"updatedAt" example:"2024-03-23T12:00:00Z"`
}

// Predefined responses

var (
	// ErrInvalidRequest 잘못된 요청
	InvalidRequest = ErrorResponse{
		Success: false,
		Code:    StatusInvalidRequest,
		Data:    "잘못된 요청입니다",
	}

	// ErrUnauthorized 인증 필요
	Unauthorized = ErrorResponse{
		Success: false,
		Code:    StatusUnauthorized,
		Data:    "인증이 필요합니다",
	}

	// ErrInvalidAuth 인증 실패
	InvalidAuth = ErrorResponse{
		Success: false,
		Code:    StatusInvalidAuth,
		Data:    "이메일 또는 비밀번호가 올바르지 않습니다",
	}

	// ErrEmailExists 이미 존재하는 이메일
	EmailExists = ErrorResponse{
		Success: false,
		Code:    StatusEmailExists,
		Data:    "이미 사용중인 이메일입니다",
	}

	// ErrNicknameExists 이미 존재하는 닉네임
	NicknameExists = ErrorResponse{
		Success: false,
		Code:    StatusNicknameExists,
		Data:    "이미 사용중인 닉네임입니다",
	}

	// ErrChatNotFound 채팅방을 찾을 수 없음
	ChatNotFound = ErrorResponse{
		Success: false,
		Code:    StatusChatNotFound,
		Data:    "채팅방을 찾을 수 없습니다",
	}

	// ErrMessageNotFound 메시지를 찾을 수 없음
	MessageNotFound = ErrorResponse{
		Success: false,
		Code:    StatusMessageNotFound,
		Data:    "메시지를 찾을 수 없습니다",
	}

	// ErrUnauthorizedMessage 메시지에 대한 권한 없음
	UnauthorizedMessage = ErrorResponse{
		Success: false,
		Code:    StatusUnauthorizedMsg,
		Data:    "메시지에 대한 권한이 없습니다",
	}

	// ErrInternalServer 내부 서버 오류
	InternalServer = ErrorResponse{
		Success: false,
		Code:    StatusInternalError,
		Data:    "내부 서버 오류가 발생했습니다",
	}

	// ErrDatabase 데이터베이스 오류
	DatabaseError = ErrorResponse{
		Success: false,
		Code:    StatusDatabaseError,
		Data:    "데이터베이스 오류가 발생했습니다",
	}
)

type ErrInvalidRequest struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4000"`
	Data    string `json:"data" example:"잘못된 요청입니다"`
}

type ErrUnauthorized struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4001"`
	Data    string `json:"data" example:"인증이 필요합니다"`
}

type ErrInvalidAuth struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4006"`
	Data    string `json:"data" example:"이메일 또는 비밀번호가 올바르지 않습니다"`
}

type ErrEmailExists struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4004"`
	Data    string `json:"data" example:"이미 사용중인 이메일입니다"`
}

type ErrNicknameExists struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4005"`
	Data    string `json:"data" example:"이미 사용중인 닉네임입니다"`
}

type ErrChatNotFound struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4007"`
	Data    string `json:"data" example:"채팅방을 찾을 수 없습니다"`
}

type ErrMessageNotFound struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4008"`
	Data    string `json:"data" example:"메시지를 찾을 수 없습니다"`
}

type ErrUnauthorizedMessage struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"4009"`
	Data    string `json:"data" example:"메시지에 대한 권한이 없습니다"`
}

type ErrInternalServer struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"5000"`
	Data    string `json:"data" example:"내부 서버 오류가 발생했습니다"`
}

type ErrDatabase struct {
	Success bool   `json:"success" example:"false"`
	Code    int    `json:"code" example:"5001"`
	Data    string `json:"data" example:"데이터베이스 오류가 발생했습니다"`
}

// Success response example
type RegisterResponse struct {
	Success bool     `json:"success" example:"true"`
	Code    int      `json:"code" example:"2001"`
	Data    AuthData `json:"data"`
}

type LoginResponse struct {
	Success bool     `json:"success" example:"true"`
	Code    int      `json:"code" example:"2000"`
	Data    AuthData `json:"data"`
}

type ChatResponse struct {
	Success bool     `json:"success" example:"true"`
	Code    int      `json:"code" example:"2000"`
	Data    ChatData `json:"data"`
}

type MessageResponse struct {
	Success bool        `json:"success" example:"true"`
	Code    int         `json:"code" example:"2000"`
	Data    MessageData `json:"data"`
}

type MessageListData struct {
	ChatId        int           `json:"chatId" example:"1"`
	Messages      []MessageData `json:"messages"`
	LastMessageId int           `json:"lastMessageId" example:"100"`
	HasMore       bool          `json:"hasMore" example:"true"`
	NextCursor    int           `json:"nextCursor" example:"50"`
}

type MessageListResponse struct {
	Success bool            `json:"success" example:"true"`
	Code    int             `json:"code" example:"2000"`
	Data    MessageListData `json:"data"`
}

type CreateChatRequest struct {
	Name    string `json:"name" example:"Team Chat" validate:"required"`
	UserIDs []int  `json:"user_ids" example:"[1,2,3]" validate:"required"`
}

================
File: config/config.go
================
package config

import (
	"github.com/joho/godotenv"
	"log"
	"os"
)

type DatabaseConfig struct {
	DSN string
}

type Config struct {
	ServerURL  string
	ServerPort string
	Database   DatabaseConfig
	JWTSecret  string
}

func LoadConfig() (*Config, error) {
	if err := godotenv.Load(); err != nil {
		log.Println("failed to load .env file")
	}
	return &Config{
		ServerURL:  getEnv("SERVER_URL", "localhost"),
		ServerPort: getEnv("SERVER_PORT", "5000"),
		Database: DatabaseConfig{
			DSN: getEnv("DATABASE_DSN", "sqlite.db"),
		},
		JWTSecret: getEnv("JWT_SECRET", "test"),
	}, nil
}

func getEnv(key, defaultValue string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return defaultValue
}

================
File: docs/docs.go
================
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/auth/login": {
            "post": {
                "description": "이메일과 비밀번호로 로그인하고 인증 토큰을 반환합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "사용자 로그인",
                "parameters": [
                    {
                        "description": "로그인 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidAuth"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/auth/register": {
            "post": {
                "description": "새로운 사용자를 등록하고 인증 토큰을 반환합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "사용자 등록",
                "parameters": [
                    {
                        "description": "등록 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.RegisterResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/common.ErrNicknameExists"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/chats/group": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "그룹 채팅방을 생성합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chat"
                ],
                "summary": "그룹 채팅 생성",
                "parameters": [
                    {
                        "description": "채팅방 생성 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.CreateGroupChatRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.ChatResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/chats/private": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "두 사용자 간의 1:1 채팅을 생성합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chat"
                ],
                "summary": "1:1 채팅 생성",
                "parameters": [
                    {
                        "description": "상대 사용자ID",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.CreatePrivateChatRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.ChatResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/chats/{chatId}/messages": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "채팅방의 메시지를 페이지네이션하여 조회합니다. 한 번에 50개의 메시지를 가져오며, 무한 스크롤을 지원합니다.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "채팅방 메시지 조회",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "채팅방 ID",
                        "name": "chatId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "커서 (이전 페이지의 마지막 메시지 ID, 첫 페이지는 0 또는 생략)",
                        "name": "cursor",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.MessageListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ErrChatNotFound"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/messages": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "채팅방에 새로운 메시지를 전송합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "메시지 전송",
                "parameters": [
                    {
                        "description": "메시지 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.SendMessageRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/messages/{id}": {
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "기존 메시지의 내용을 수정합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "메시지 수정",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "메시지 ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "수정할 메시지 내용",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.UpdateMessageRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/common.ErrUnauthorizedMessage"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "메시지를 삭제합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "메시지 삭제",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "메시지 ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/common.ErrUnauthorizedMessage"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "common.AuthData": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "user": {
                    "$ref": "#/definitions/common.UserData"
                }
            }
        },
        "common.ChatData": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "name": {
                    "type": "string",
                    "example": "개발팀 채팅방"
                }
            }
        },
        "common.ChatResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.ChatData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.ErrChatNotFound": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4007
                },
                "data": {
                    "type": "string",
                    "example": "채팅방을 찾을 수 없습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrEmailExists": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4004
                },
                "data": {
                    "type": "string",
                    "example": "이미 사용중인 이메일입니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrInternalServer": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 5000
                },
                "data": {
                    "type": "string",
                    "example": "내부 서버 오류가 발생했습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrInvalidAuth": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4006
                },
                "data": {
                    "type": "string",
                    "example": "이메일 또는 비밀번호가 올바르지 않습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrInvalidRequest": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4000
                },
                "data": {
                    "type": "string",
                    "example": "잘못된 요청입니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrNicknameExists": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4005
                },
                "data": {
                    "type": "string",
                    "example": "이미 사용중인 닉네임입니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrUnauthorizedMessage": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4009
                },
                "data": {
                    "type": "string",
                    "example": "메시지에 대한 권한이 없습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.LoginResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.AuthData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.MessageData": {
            "type": "object",
            "properties": {
                "chatId": {
                    "type": "integer",
                    "example": 1
                },
                "content": {
                    "type": "string",
                    "example": "안녕하세요"
                },
                "createdAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "senderId": {
                    "type": "integer",
                    "example": 1
                },
                "senderNickname": {
                    "type": "string",
                    "example": "홍길동"
                },
                "updatedAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                }
            }
        },
        "common.MessageListData": {
            "type": "object",
            "properties": {
                "chatId": {
                    "type": "integer",
                    "example": 1
                },
                "hasMore": {
                    "type": "boolean",
                    "example": true
                },
                "lastMessageId": {
                    "type": "integer",
                    "example": 100
                },
                "messages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/common.MessageData"
                    }
                },
                "nextCursor": {
                    "type": "integer",
                    "example": 50
                }
            }
        },
        "common.MessageListResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.MessageListData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.MessageResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.MessageData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.RegisterResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2001
                },
                "data": {
                    "$ref": "#/definitions/common.AuthData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.UserData": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                },
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "nickname": {
                    "type": "string",
                    "example": "홍길동"
                }
            }
        },
        "controllers.CreateGroupChatRequest": {
            "type": "object"
        },
        "controllers.CreatePrivateChatRequest": {
            "type": "object",
            "properties": {
                "targetId": {
                    "type": "integer",
                    "example": 1
                }
            }
        },
        "controllers.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "password": {
                    "type": "string",
                    "example": "password123"
                }
            }
        },
        "controllers.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "nickname",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "nickname": {
                    "type": "string",
                    "maxLength": 20,
                    "minLength": 2,
                    "example": "홍길동"
                },
                "password": {
                    "type": "string",
                    "minLength": 8,
                    "example": "password123"
                }
            }
        },
        "controllers.SendMessageRequest": {
            "type": "object",
            "required": [
                "chatId",
                "content"
            ],
            "properties": {
                "chatId": {
                    "type": "integer",
                    "example": 1
                },
                "content": {
                    "type": "string",
                    "example": "Hello, how are you?"
                }
            }
        },
        "controllers.UpdateMessageRequest": {
            "type": "object",
            "required": [
                "content"
            ],
            "properties": {
                "content": {
                    "type": "string",
                    "example": "Updated message content"
                }
            }
        }
    },
    "securityDefinitions": {
        "Bearer": {
            "description": "'Bearer ' 접두사와 함께 JWT 토큰을 입력하세요. 예시: \"Bearer eyJhbGciOi...\"",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    },
    "security": [
        {
            "Bearer": []
        }
    ]
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:5050",
	BasePath:         "/",
	Schemes:          []string{},
	Title:            "Realtime Chat API",
	Description:      "실시간 채팅을 위한 RESTful API 서버입니다.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}

================
File: docs/swagger.json
================
{
    "swagger": "2.0",
    "info": {
        "description": "실시간 채팅을 위한 RESTful API 서버입니다.",
        "title": "Realtime Chat API",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "1.0"
    },
    "host": "localhost:5050",
    "basePath": "/",
    "paths": {
        "/api/auth/login": {
            "post": {
                "description": "이메일과 비밀번호로 로그인하고 인증 토큰을 반환합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "사용자 로그인",
                "parameters": [
                    {
                        "description": "로그인 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidAuth"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/auth/register": {
            "post": {
                "description": "새로운 사용자를 등록하고 인증 토큰을 반환합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "사용자 등록",
                "parameters": [
                    {
                        "description": "등록 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.RegisterResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/common.ErrNicknameExists"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/chats/group": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "그룹 채팅방을 생성합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chat"
                ],
                "summary": "그룹 채팅 생성",
                "parameters": [
                    {
                        "description": "채팅방 생성 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.CreateGroupChatRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.ChatResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/chats/private": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "두 사용자 간의 1:1 채팅을 생성합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chat"
                ],
                "summary": "1:1 채팅 생성",
                "parameters": [
                    {
                        "description": "상대 사용자ID",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.CreatePrivateChatRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.ChatResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/chats/{chatId}/messages": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "채팅방의 메시지를 페이지네이션하여 조회합니다. 한 번에 50개의 메시지를 가져오며, 무한 스크롤을 지원합니다.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "채팅방 메시지 조회",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "채팅방 ID",
                        "name": "chatId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "커서 (이전 페이지의 마지막 메시지 ID, 첫 페이지는 0 또는 생략)",
                        "name": "cursor",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.MessageListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ErrChatNotFound"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/messages": {
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "채팅방에 새로운 메시지를 전송합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "메시지 전송",
                "parameters": [
                    {
                        "description": "메시지 정보",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.SendMessageRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/common.MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        },
        "/api/messages/{id}": {
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "기존 메시지의 내용을 수정합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "메시지 수정",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "메시지 ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "수정할 메시지 내용",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.UpdateMessageRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/common.ErrUnauthorizedMessage"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "메시지를 삭제합니다",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Message"
                ],
                "summary": "메시지 삭제",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "메시지 ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInvalidRequest"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/common.ErrUnauthorizedMessage"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ErrInternalServer"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "common.AuthData": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                },
                "user": {
                    "$ref": "#/definitions/common.UserData"
                }
            }
        },
        "common.ChatData": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "name": {
                    "type": "string",
                    "example": "개발팀 채팅방"
                }
            }
        },
        "common.ChatResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.ChatData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.ErrChatNotFound": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4007
                },
                "data": {
                    "type": "string",
                    "example": "채팅방을 찾을 수 없습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrEmailExists": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4004
                },
                "data": {
                    "type": "string",
                    "example": "이미 사용중인 이메일입니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrInternalServer": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 5000
                },
                "data": {
                    "type": "string",
                    "example": "내부 서버 오류가 발생했습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrInvalidAuth": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4006
                },
                "data": {
                    "type": "string",
                    "example": "이메일 또는 비밀번호가 올바르지 않습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrInvalidRequest": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4000
                },
                "data": {
                    "type": "string",
                    "example": "잘못된 요청입니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrNicknameExists": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4005
                },
                "data": {
                    "type": "string",
                    "example": "이미 사용중인 닉네임입니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.ErrUnauthorizedMessage": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 4009
                },
                "data": {
                    "type": "string",
                    "example": "메시지에 대한 권한이 없습니다"
                },
                "success": {
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "common.LoginResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.AuthData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.MessageData": {
            "type": "object",
            "properties": {
                "chatId": {
                    "type": "integer",
                    "example": 1
                },
                "content": {
                    "type": "string",
                    "example": "안녕하세요"
                },
                "createdAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "senderId": {
                    "type": "integer",
                    "example": 1
                },
                "senderNickname": {
                    "type": "string",
                    "example": "홍길동"
                },
                "updatedAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                }
            }
        },
        "common.MessageListData": {
            "type": "object",
            "properties": {
                "chatId": {
                    "type": "integer",
                    "example": 1
                },
                "hasMore": {
                    "type": "boolean",
                    "example": true
                },
                "lastMessageId": {
                    "type": "integer",
                    "example": 100
                },
                "messages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/common.MessageData"
                    }
                },
                "nextCursor": {
                    "type": "integer",
                    "example": 50
                }
            }
        },
        "common.MessageListResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.MessageListData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.MessageResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2000
                },
                "data": {
                    "$ref": "#/definitions/common.MessageData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.RegisterResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 2001
                },
                "data": {
                    "$ref": "#/definitions/common.AuthData"
                },
                "success": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "common.UserData": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "example": "2024-03-23T12:00:00Z"
                },
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "nickname": {
                    "type": "string",
                    "example": "홍길동"
                }
            }
        },
        "controllers.CreateGroupChatRequest": {
            "type": "object"
        },
        "controllers.CreatePrivateChatRequest": {
            "type": "object",
            "properties": {
                "targetId": {
                    "type": "integer",
                    "example": 1
                }
            }
        },
        "controllers.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "password": {
                    "type": "string",
                    "example": "password123"
                }
            }
        },
        "controllers.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "nickname",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "nickname": {
                    "type": "string",
                    "maxLength": 20,
                    "minLength": 2,
                    "example": "홍길동"
                },
                "password": {
                    "type": "string",
                    "minLength": 8,
                    "example": "password123"
                }
            }
        },
        "controllers.SendMessageRequest": {
            "type": "object",
            "required": [
                "chatId",
                "content"
            ],
            "properties": {
                "chatId": {
                    "type": "integer",
                    "example": 1
                },
                "content": {
                    "type": "string",
                    "example": "Hello, how are you?"
                }
            }
        },
        "controllers.UpdateMessageRequest": {
            "type": "object",
            "required": [
                "content"
            ],
            "properties": {
                "content": {
                    "type": "string",
                    "example": "Updated message content"
                }
            }
        }
    },
    "securityDefinitions": {
        "Bearer": {
            "description": "'Bearer ' 접두사와 함께 JWT 토큰을 입력하세요. 예시: \"Bearer eyJhbGciOi...\"",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    },
    "security": [
        {
            "Bearer": []
        }
    ]
}

================
File: docs/swagger.yaml
================
basePath: /
definitions:
  common.AuthData:
    properties:
      token:
        example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        type: string
      user:
        $ref: '#/definitions/common.UserData'
    type: object
  common.ChatData:
    properties:
      createdAt:
        example: "2024-03-23T12:00:00Z"
        type: string
      id:
        example: 1
        type: integer
      name:
        example: 개발팀 채팅방
        type: string
    type: object
  common.ChatResponse:
    properties:
      code:
        example: 2000
        type: integer
      data:
        $ref: '#/definitions/common.ChatData'
      success:
        example: true
        type: boolean
    type: object
  common.ErrChatNotFound:
    properties:
      code:
        example: 4007
        type: integer
      data:
        example: 채팅방을 찾을 수 없습니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.ErrEmailExists:
    properties:
      code:
        example: 4004
        type: integer
      data:
        example: 이미 사용중인 이메일입니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.ErrInternalServer:
    properties:
      code:
        example: 5000
        type: integer
      data:
        example: 내부 서버 오류가 발생했습니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.ErrInvalidAuth:
    properties:
      code:
        example: 4006
        type: integer
      data:
        example: 이메일 또는 비밀번호가 올바르지 않습니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.ErrInvalidRequest:
    properties:
      code:
        example: 4000
        type: integer
      data:
        example: 잘못된 요청입니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.ErrNicknameExists:
    properties:
      code:
        example: 4005
        type: integer
      data:
        example: 이미 사용중인 닉네임입니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.ErrUnauthorizedMessage:
    properties:
      code:
        example: 4009
        type: integer
      data:
        example: 메시지에 대한 권한이 없습니다
        type: string
      success:
        example: false
        type: boolean
    type: object
  common.LoginResponse:
    properties:
      code:
        example: 2000
        type: integer
      data:
        $ref: '#/definitions/common.AuthData'
      success:
        example: true
        type: boolean
    type: object
  common.MessageData:
    properties:
      chatId:
        example: 1
        type: integer
      content:
        example: 안녕하세요
        type: string
      createdAt:
        example: "2024-03-23T12:00:00Z"
        type: string
      id:
        example: 1
        type: integer
      senderId:
        example: 1
        type: integer
      senderNickname:
        example: 홍길동
        type: string
      updatedAt:
        example: "2024-03-23T12:00:00Z"
        type: string
    type: object
  common.MessageListData:
    properties:
      chatId:
        example: 1
        type: integer
      hasMore:
        example: true
        type: boolean
      lastMessageId:
        example: 100
        type: integer
      messages:
        items:
          $ref: '#/definitions/common.MessageData'
        type: array
      nextCursor:
        example: 50
        type: integer
    type: object
  common.MessageListResponse:
    properties:
      code:
        example: 2000
        type: integer
      data:
        $ref: '#/definitions/common.MessageListData'
      success:
        example: true
        type: boolean
    type: object
  common.MessageResponse:
    properties:
      code:
        example: 2000
        type: integer
      data:
        $ref: '#/definitions/common.MessageData'
      success:
        example: true
        type: boolean
    type: object
  common.RegisterResponse:
    properties:
      code:
        example: 2001
        type: integer
      data:
        $ref: '#/definitions/common.AuthData'
      success:
        example: true
        type: boolean
    type: object
  common.UserData:
    properties:
      createdAt:
        example: "2024-03-23T12:00:00Z"
        type: string
      email:
        example: user@example.com
        type: string
      id:
        example: 1
        type: integer
      nickname:
        example: 홍길동
        type: string
    type: object
  controllers.CreateGroupChatRequest:
    type: object
  controllers.CreatePrivateChatRequest:
    properties:
      targetId:
        example: 1
        type: integer
    type: object
  controllers.LoginRequest:
    properties:
      email:
        example: user@example.com
        type: string
      password:
        example: password123
        type: string
    required:
    - email
    - password
    type: object
  controllers.RegisterRequest:
    properties:
      email:
        example: user@example.com
        type: string
      nickname:
        example: 홍길동
        maxLength: 20
        minLength: 2
        type: string
      password:
        example: password123
        minLength: 8
        type: string
    required:
    - email
    - nickname
    - password
    type: object
  controllers.SendMessageRequest:
    properties:
      chatId:
        example: 1
        type: integer
      content:
        example: Hello, how are you?
        type: string
    required:
    - chatId
    - content
    type: object
  controllers.UpdateMessageRequest:
    properties:
      content:
        example: Updated message content
        type: string
    required:
    - content
    type: object
host: localhost:5050
info:
  contact:
    email: support@swagger.io
    name: API Support
    url: http://www.swagger.io/support
  description: 실시간 채팅을 위한 RESTful API 서버입니다.
  license:
    name: Apache 2.0
    url: http://www.apache.org/licenses/LICENSE-2.0.html
  termsOfService: http://swagger.io/terms/
  title: Realtime Chat API
  version: "1.0"
paths:
  /api/auth/login:
    post:
      consumes:
      - application/json
      description: 이메일과 비밀번호로 로그인하고 인증 토큰을 반환합니다
      parameters:
      - description: 로그인 정보
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/controllers.LoginRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/common.LoginResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/common.ErrInvalidAuth'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      summary: 사용자 로그인
      tags:
      - Auth
  /api/auth/register:
    post:
      consumes:
      - application/json
      description: 새로운 사용자를 등록하고 인증 토큰을 반환합니다
      parameters:
      - description: 등록 정보
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/controllers.RegisterRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/common.RegisterResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "409":
          description: Conflict
          schema:
            $ref: '#/definitions/common.ErrNicknameExists'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      summary: 사용자 등록
      tags:
      - Auth
  /api/chats/{chatId}/messages:
    get:
      consumes:
      - application/json
      description: 채팅방의 메시지를 페이지네이션하여 조회합니다. 한 번에 50개의 메시지를 가져오며, 무한 스크롤을 지원합니다.
      parameters:
      - description: 채팅방 ID
        in: path
        name: chatId
        required: true
        type: integer
      - description: 커서 (이전 페이지의 마지막 메시지 ID, 첫 페이지는 0 또는 생략)
        in: query
        name: cursor
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/common.MessageListResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/common.ErrChatNotFound'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      security:
      - Bearer: []
      summary: 채팅방 메시지 조회
      tags:
      - Message
  /api/chats/group:
    post:
      consumes:
      - application/json
      description: 그룹 채팅방을 생성합니다
      parameters:
      - description: 채팅방 생성 정보
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/controllers.CreateGroupChatRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/common.ChatResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      security:
      - Bearer: []
      summary: 그룹 채팅 생성
      tags:
      - Chat
  /api/chats/private:
    post:
      consumes:
      - application/json
      description: 두 사용자 간의 1:1 채팅을 생성합니다
      parameters:
      - description: 상대 사용자ID
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/controllers.CreatePrivateChatRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/common.ChatResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      security:
      - Bearer: []
      summary: 1:1 채팅 생성
      tags:
      - Chat
  /api/messages:
    post:
      consumes:
      - application/json
      description: 채팅방에 새로운 메시지를 전송합니다
      parameters:
      - description: 메시지 정보
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/controllers.SendMessageRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/common.MessageResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      security:
      - Bearer: []
      summary: 메시지 전송
      tags:
      - Message
  /api/messages/{id}:
    delete:
      consumes:
      - application/json
      description: 메시지를 삭제합니다
      parameters:
      - description: 메시지 ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/common.MessageResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "403":
          description: Forbidden
          schema:
            $ref: '#/definitions/common.ErrUnauthorizedMessage'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      security:
      - Bearer: []
      summary: 메시지 삭제
      tags:
      - Message
    put:
      consumes:
      - application/json
      description: 기존 메시지의 내용을 수정합니다
      parameters:
      - description: 메시지 ID
        in: path
        name: id
        required: true
        type: integer
      - description: 수정할 메시지 내용
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/controllers.UpdateMessageRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/common.MessageResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/common.ErrInvalidRequest'
        "403":
          description: Forbidden
          schema:
            $ref: '#/definitions/common.ErrUnauthorizedMessage'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/common.ErrInternalServer'
      security:
      - Bearer: []
      summary: 메시지 수정
      tags:
      - Message
security:
- Bearer: []
securityDefinitions:
  Bearer:
    description: '''Bearer '' 접두사와 함께 JWT 토큰을 입력하세요. 예시: "Bearer eyJhbGciOi..."'
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"

================
File: domain/dto/message_dto.go
================
package dto

import (
	"time"

	"github.com/f1rstid/realtime-chat/domain/models"
)

// MessageResponse is a DTO for message responses
type MessageResponse struct {
	ID             int       `json:"id"`
	ChatID         int       `json:"chatId"`
	SenderID       int       `json:"senderId"`
	SenderNickname string    `json:"senderNickname"`
	Content        string    `json:"content"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// ChatMessagesResponse represents the response for chat messages with pagination
type ChatMessagesResponse struct {
	ChatId        int               `json:"chatId"`
	Messages      []MessageResponse `json:"messages"`
	LastMessageId int               `json:"lastMessageId"`
	HasMore       bool              `json:"hasMore"`
	NextCursor    int               `json:"nextCursor"`
}

// NewMessageResponse creates a new MessageResponse from a Message model
func NewMessageResponse(message *models.Message) *MessageResponse {
	return &MessageResponse{
		ID:             message.ID,
		ChatID:         message.ChatId,
		SenderID:       message.SenderId,
		SenderNickname: message.SenderNickname,
		Content:        message.Content,
		CreatedAt:      message.CreatedAt,
		UpdatedAt:      message.UpdatedAt,
	}
}

// NewMessageResponseList creates a list of MessageResponse from Message models
func NewMessageResponseList(messages []models.Message) []MessageResponse {
	responses := make([]MessageResponse, len(messages))
	for i, message := range messages {
		responses[i] = *NewMessageResponse(&message)
	}
	return responses
}

================
File: domain/events/websocket_events.go
================
// domain/events/websocket_events.go

package events

import (
	"encoding/json"
	"time"
)

// Event types
const (
	EventMessageCreated = "message.created"
	EventMessageUpdated = "message.updated"
	EventMessageDeleted = "message.deleted"
)

// Common response codes
const (
	StatusSuccess = 2000
	StatusCreated = 2001
)

// WebSocketResponse represents the unified response structure for both REST and WebSocket
type WebSocketResponse struct {
	Success   bool        `json:"success"`
	Code      int         `json:"code"`
	Data      interface{} `json:"data"`
	Timestamp time.Time   `json:"timestamp"`
}

// MessageEventData represents the data structure for message events
type MessageEventData struct {
	Type           string    `json:"type"`
	MessageID      int       `json:"messageId"`
	ChatID         int       `json:"chatId"`
	SenderID       int       `json:"senderId"`
	SenderNickname string    `json:"senderNickname"`
	Content        string    `json:"content,omitempty"`
	CreatedAt      time.Time `json:"createdAt,omitempty"`
	UpdatedAt      time.Time `json:"updatedAt,omitempty"`
}

// NewWebSocketEvent creates a new WebSocket event with unified response format
func NewWebSocketEvent(eventType string, chatID int, data interface{}) *WebSocketResponse {
	eventData := MessageEventData{
		Type: eventType,
	}

	// Type assertion for different event types
	switch v := data.(type) {
	case *MessageEventData:
		eventData.MessageID = v.MessageID
		eventData.ChatID = v.ChatID
		eventData.SenderID = v.SenderID
		eventData.SenderNickname = v.SenderNickname
		eventData.Content = v.Content
		eventData.CreatedAt = v.CreatedAt
		eventData.UpdatedAt = v.UpdatedAt
	}

	return &WebSocketResponse{
		Success:   true,
		Code:      StatusSuccess,
		Data:      eventData,
		Timestamp: time.Now(),
	}
}

// ToJSON converts the WebSocket response to JSON bytes
func (r *WebSocketResponse) ToJSON() ([]byte, error) {
	return json.Marshal(r)
}

================
File: domain/models/chat_group.go
================
package models

import "time"

type ChatGroup struct {
	Name      string    `json:"name" db:"name"`
	UserId    int       `json:"userId" db:"userId"`
	ChatId    int       `json:"chatId" db:"chatId"`
	CreatedAt time.Time `json:"createdAt" db:"createdAt"`

	Users []User `json:"users" gorm:"many2many:chat_group_users;"`
	Chats []Chat `json:"chats" gorm:"many2many:chat_group_chats;"`
}

================
File: domain/models/chat.go
================
package models

import "time"

type Chat struct {
	ID        int       `json:"id" db:"id"`
	Name      string    `json:"name" db:"name"`
	CreatedAt time.Time `json:"createdAt" db:"createdAt"`

	ChatGroups []ChatGroup `json:"chatGroups" gorm:"many2many:chat_group_chats;"`
	Messages   []Message   `json:"messages" gorm:"foreignKey:chatId;"`
}

================
File: domain/models/message.go
================
package models

import "time"

type Message struct {
	ID             int       `json:"id" db:"id"`
	ChatId         int       `json:"chatId" db:"chatId"`
	SenderId       int       `json:"senderId" db:"senderId"`
	SenderNickname string    `json:"senderNickname" db:"senderNickname"`
	Content        string    `json:"content" db:"content"`
	CreatedAt      time.Time `json:"createdAt" db:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt" db:"updatedAt"`

	Chat   Chat `json:"chat" gorm:"foreignKey:chatId;"`
	Sender User `json:"sender" gorm:"foreignKey:senderId;"`
}

================
File: domain/models/user.go
================
package models

import (
	"errors"
	"regexp"
	"time"
)

type User struct {
	ID        int       `json:"id" db:"id"`
	Email     string    `json:"email" db:"email"`
	Nickname  string    `json:"nickname" db:"nickname"`
	Password  string    `json:"-" db:"password"` // "-" prevents password from being included in JSON
	CreatedAt time.Time `json:"createdAt" db:"createdAt"`
}

// Validate performs validation on user fields
func (u *User) Validate() error {
	// Email validation
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	if !emailRegex.MatchString(u.Email) {
		return errors.New("invalid email format")
	}

	// Nickname validation
	if len(u.Nickname) < 2 || len(u.Nickname) > 20 {
		return errors.New("nickname must be between 2 and 20 characters")
	}
	nicknameRegex := regexp.MustCompile(`^[a-zA-Z0-9가-힣_.]+$`)
	if !nicknameRegex.MatchString(u.Nickname) {
		return errors.New("nickname can only contain letters, numbers and underscores")
	}

	// Password validation (performed before hashing)
	if len(u.Password) < 1 { // Corrected minimum password length
		return errors.New("password must be at least 8 characters")
	}

	return nil
}

================
File: domain/repositories/chat_repository.go
================
package repositories

import "github.com/f1rstid/realtime-chat/domain/models"

type ChatRepository interface {
	Create(chat *models.Chat) error
	FindById(id int) (*models.Chat, error)
	Update(chat *models.Chat) error
	Delete(id int) error

	AddUserToChat(chatID, userID int) error
	RemoveUserFromChat(chatID, userID int) error
	GetChatUsers(chatID int) ([]models.User, error)
	GetUserChats(userID int) ([]models.Chat, error)
}

================
File: domain/repositories/message_repository.go
================
package repositories

import "github.com/f1rstid/realtime-chat/domain/models"

type MessageRepository interface {
	Create(message *models.Message) error
	FindById(id int) (*models.Message, error)
	Update(message *models.Message) error
	Delete(id int) error
	FindByChatId(chatId int, cursor int, limit int) ([]models.Message, error)
	GetLastMessageId(chatId int) (int, error)
}

================
File: domain/repositories/user_repository.go
================
package repositories

import "github.com/f1rstid/realtime-chat/domain/models"

type UserRepository interface {
	Create(user *models.User) (*models.User, error)
	FindByID(id int) (*models.User, error)
	FindByEmail(email string) (*models.User, error)
	FindByNickname(nickname string) (*models.User, error)
	Update(user *models.User) error
	Delete(id int) error
}

================
File: domain/services/auth_service.go
================
package services

import (
	"errors"
	"time"

	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/golang-jwt/jwt/v4"
	"golang.org/x/crypto/bcrypt"
)

type TokenClaims struct {
	UserID   int    `json:"user_id"`
	Email    string `json:"email"`
	Nickname string `json:"nickname"`
	jwt.StandardClaims
}

type AuthService interface {
	HashPassword(password string) (string, error)
	ComparePassword(hashedPassword, password string) error
	GenerateToken(user *models.User) (string, error)
	ValidateToken(tokenString string) (*TokenClaims, error)
	RefreshToken(tokenString string) (string, error)
}

type authService struct {
	jwtSecret       string
	tokenExpiration time.Duration
	refreshDuration time.Duration
	passwordCost    int
}

func NewAuthService(jwtSecret string) AuthService {
	return &authService{
		jwtSecret:       jwtSecret,
		tokenExpiration: 24 * time.Hour, // Token expires in 24 hours
		refreshDuration: 72 * time.Hour, // Refresh token valid for 72 hours
		passwordCost:    5,              // Higher cost = more secure but slower
	}
}

func (a *authService) HashPassword(password string) (string, error) {
	if len(password) < 8 {
		return "", errors.New("password must be at least 8 characters")
	}

	hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), a.passwordCost)
	if err != nil {
		return "", errors.New("failed to hash password")
	}

	return string(hashedBytes), nil
}

func (a *authService) ComparePassword(hashedPassword, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}

func (a *authService) GenerateToken(user *models.User) (string, error) {
	claims := TokenClaims{
		UserID:   user.ID,
		Email:    user.Email,
		Nickname: user.Nickname,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: time.Now().Add(a.tokenExpiration).Unix(),
			IssuedAt:  time.Now().Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	signedToken, err := token.SignedString([]byte(a.jwtSecret))
	if err != nil {
		return "", errors.New("failed to generate token")
	}

	return signedToken, nil
}

func (a *authService) ValidateToken(tokenString string) (*TokenClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &TokenClaims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("unexpected signing method")
		}
		return []byte(a.jwtSecret), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*TokenClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, errors.New("invalid token")
}

func (a *authService) RefreshToken(tokenString string) (string, error) {
	claims, err := a.ValidateToken(tokenString)
	if err != nil {
		return "", err
	}

	// Check if token is eligible for refresh
	if time.Unix(claims.ExpiresAt, 0).Sub(time.Now()) > -a.refreshDuration {
		// Create new token
		user := &models.User{
			ID:       claims.UserID,
			Email:    claims.Email,
			Nickname: claims.Nickname,
		}
		return a.GenerateToken(user)
	}

	return "", errors.New("refresh token expired")
}

================
File: domain/services/chat_service.go
================
package services

import (
	"encoding/json"
	"time"

	"github.com/f1rstid/realtime-chat/domain/models"
)

type ChatMessage struct {
	Type      string    `json:"type"`
	ChatID    int       `json:"chat_id"`
	SenderID  int       `json:"sender_id"`
	Content   string    `json:"content"`
	Timestamp time.Time `json:"timestamp"`
}

type ChatService struct {
	// You can add dependencies here if needed
}

func NewChatService() *ChatService {
	return &ChatService{}
}

// ParseMessage parses a raw message into a ChatMessage struct
func (cs *ChatService) ParseMessage(data []byte) (*ChatMessage, error) {
	var message ChatMessage
	if err := json.Unmarshal(data, &message); err != nil {
		return nil, err
	}
	return &message, nil
}

// FormatMessage formats a Message model into a ChatMessage
func (cs *ChatService) FormatMessage(message *models.Message) (*ChatMessage, error) {
	chatMessage := &ChatMessage{
		Type:      "message",
		ChatID:    message.ChatId,
		SenderID:  message.SenderId,
		Content:   message.Content,
		Timestamp: message.CreatedAt,
	}

	return chatMessage, nil
}

================
File: infrastructure/logger/logger.go
================
// infrastructure/logger/logger.go
package logger

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"time"
)

var (
	infoLogger    *log.Logger
	errorLogger   *log.Logger
	requestLogger *log.Logger
)

const (
	colorReset  = "\033[0m"
	colorRed    = "\033[31m"
	colorGreen  = "\033[32m"
	colorYellow = "\033[33m"
	colorBlue   = "\033[34m"
	colorPurple = "\033[35m"
	colorCyan   = "\033[36m"
	colorGray   = "\033[37m"
)

// getLogPrefix returns colored prefix with timestamp
func getLogPrefix(level string) string {
	var color string
	switch level {
	case "INFO":
		color = colorGreen
	case "ERROR":
		color = colorRed
	case "REQUEST":
		color = colorBlue
	default:
		color = colorReset
	}

	timestamp := time.Now().Format("2006-01-02 15:04:05")
	return fmt.Sprintf("%s%s [%s]%s ", colorGray, timestamp, level, color)
}

func init() {
	// 로그 파일 디렉토리 생성
	logDir := "logs"
	if err := os.MkdirAll(logDir, 0755); err != nil {
		log.Fatal("Failed to create log directory:", err)
	}

	// 현재 날짜로 로그 파일 생성
	currentTime := time.Now()
	date := currentTime.Format("2006-01-02")

	// 일반 로그 파일
	infoLogFile, err := os.OpenFile(
		filepath.Join(logDir, fmt.Sprintf("app_%s.log", date)),
		os.O_APPEND|os.O_CREATE|os.O_WRONLY,
		0644,
	)
	if err != nil {
		log.Fatal("Failed to open info log file:", err)
	}

	// 에러 로그 파일
	errorLogFile, err := os.OpenFile(
		filepath.Join(logDir, fmt.Sprintf("error_%s.log", date)),
		os.O_APPEND|os.O_CREATE|os.O_WRONLY,
		0644,
	)
	if err != nil {
		log.Fatal("Failed to open error log file:", err)
	}

	// HTTP 요청 로그 파일
	requestLogFile, err := os.OpenFile(
		filepath.Join(logDir, fmt.Sprintf("request_%s.log", date)),
		os.O_APPEND|os.O_CREATE|os.O_WRONLY,
		0644,
	)
	if err != nil {
		log.Fatal("Failed to open request log file:", err)
	}

	// MultiWriter를 사용하여 파일과 콘솔에 동시에 출력
	infoWriter := io.MultiWriter(os.Stdout, infoLogFile)
	errorWriter := io.MultiWriter(os.Stdout, errorLogFile)
	requestWriter := io.MultiWriter(os.Stdout, requestLogFile)

	// 로거 초기화
	infoLogger = log.New(infoWriter, "", 0)
	errorLogger = log.New(errorWriter, "", 0)
	requestLogger = log.New(requestWriter, "", 0)
}

// formatLog formats the log message with file info and color
func formatLog(level, file string, line int, msg string) string {
	prefix := getLogPrefix(level)
	return fmt.Sprintf("%s%s:%d: %s%s\n",
		prefix, filepath.Base(file), line, msg, colorReset)
}

// Info logs general information
func Info(format string, v ...interface{}) {
	_, file, line, _ := runtime.Caller(1)
	msg := fmt.Sprintf(format, v...)
	formattedMsg := formatLog("INFO", file, line, msg)
	infoLogger.Print(formattedMsg)
}

// Error logs error information
func Error(format string, v ...interface{}) {
	_, file, line, _ := runtime.Caller(1)
	msg := fmt.Sprintf(format, v...)
	formattedMsg := formatLog("ERROR", file, line, msg)
	errorLogger.Print(formattedMsg)
}

// LogRequest logs HTTP request information
func LogRequest(method, path, ip, userAgent string, statusCode int, duration time.Duration) {
	_, file, line, _ := runtime.Caller(1)
	msg := fmt.Sprintf(
		"Method: %s, Path: %s, IP: %s, Status: %d, Duration: %v",
		method, path, ip, statusCode, duration,
	)
	formattedMsg := formatLog("REQUEST", file, line, msg)
	requestLogger.Print(formattedMsg)
}

// LogError logs error with request context
func LogError(err error, method, path string) {
	_, file, line, _ := runtime.Caller(1)
	msg := fmt.Sprintf("Method: %s, Path: %s, Error: %v", method, path, err)
	formattedMsg := formatLog("ERROR", file, line, msg)
	errorLogger.Print(formattedMsg)
}

// Debug logs debug information (only in development)
func Debug(format string, v ...interface{}) {
	if os.Getenv("GO_ENV") != "production" {
		_, file, line, _ := runtime.Caller(1)
		msg := fmt.Sprintf(format, v...)
		formattedMsg := formatLog("DEBUG", file, line, msg)
		infoLogger.Print(formattedMsg)
	}
}

================
File: infrastructure/sqlite/initialize.go
================
package sqlite

import (
	"github.com/gofiber/websocket/v2"
	"log"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
)

var DB *sqlx.DB

func InitDB(dataSource string) error {
	var err error
	DB, err = sqlx.Open("sqlite3", dataSource)
	if err != nil {
		return err
	}

	// Set connection pool settings
	DB.SetMaxOpenConns(25)
	DB.SetMaxIdleConns(25)
	DB.SetConnMaxLifetime(5 * time.Minute)

	err = DB.Ping()
	if err != nil {
		return err
	}

	return nil
}

func Migrate() error {
	sql := `
	-- Users table
	CREATE TABLE IF NOT EXISTS users (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		email TEXT NOT NULL UNIQUE,
		password TEXT NOT NULL,
		nickname TEXT NOT NULL UNIQUE,
		createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
	);

	-- Chats table
	CREATE TABLE IF NOT EXISTS chats (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL,
		createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
	);

	-- Messages table
	CREATE TABLE IF NOT EXISTS messages (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		chatId INTEGER NOT NULL,
		senderId INTEGER NOT NULL,
		content TEXT NOT NULL,
		createdAt DATETIME NOT NULL,
		updatedAt DATETIME NOT NULL,
		FOREIGN KEY (chatId) REFERENCES chats(id) ON DELETE CASCADE,
		FOREIGN KEY (senderId) REFERENCES users(id) ON DELETE CASCADE
	);

	-- Chat groups table (for group chats)
	CREATE TABLE IF NOT EXISTS chat_groups (
		chatId INTEGER NOT NULL,
		userId INTEGER NOT NULL,
		createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
		PRIMARY KEY (chatId, userId),
		FOREIGN KEY (chatId) REFERENCES chats(id) ON DELETE CASCADE,
		FOREIGN KEY (userId) REFERENCES users(id) ON DELETE CASCADE
	);

	-- Create indexes
	CREATE INDEX IF NOT EXISTS idx_messages_chatId ON messages(chatId);
	CREATE INDEX IF NOT EXISTS idx_messages_senderId ON messages(senderId);
	CREATE INDEX IF NOT EXISTS idx_chat_groups_chatId ON chat_groups(chatId);
	CREATE INDEX IF NOT EXISTS idx_chat_groups_userId ON chat_groups(userId);
	`

	_, err := DB.Exec(sql)
	if err != nil {
		return err
	}

	log.Println("Database migration completed successfully")
	return nil
}

func CloseDB() {
	if err := DB.Close(); err != nil {
		log.Printf("Error closing database connection: %v", err)
	}
}

// WebSocket hub for managing connections and broadcasting messages
type Hub struct {
	// Registered clients
	clients map[*Client]bool

	// Register requests from clients
	register chan *Client

	// Unregister requests from clients
	unregister chan *Client

	// Broadcast messages to clients
	broadcast chan []byte
}

type Client struct {
	hub  *Hub
	conn *websocket.Conn
	send chan []byte
	// User ID associated with this connection
	userID int
}

func newHub() *Hub {
	return &Hub{
		broadcast:  make(chan []byte),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		clients:    make(map[*Client]bool),
	}
}

func (h *Hub) run() {
	for {
		select {
		case client := <-h.register:
			h.clients[client] = true
		case client := <-h.unregister:
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send)
			}
		case message := <-h.broadcast:
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					close(client.send)
					delete(h.clients, client)
				}
			}
		}
	}
}

================
File: infrastructure/websocket/hub.go
================
// infrastructure/websocket/hub.go
package websocket

import (
	"sync"

	"github.com/f1rstid/realtime-chat/infrastructure/logger"
	"github.com/gofiber/websocket/v2"
)

// Hub maintains the set of active clients and broadcasts messages to the clients
type Hub struct {
	// Registered clients by chat ID
	clients map[int]map[*Client]bool

	// Channel for broadcasting messages
	broadcast chan []byte

	// Register requests from the clients
	register chan *Client

	// Unregister requests from clients
	unregister chan *Client

	// Mutex for thread-safe operations on the clients map
	mu sync.RWMutex
}

// Client represents a connected WebSocket client
type Client struct {
	Hub    *Hub
	Conn   *websocket.Conn
	Send   chan []byte
	UserID int
	ChatID int
}

// NewHub creates a new Hub instance
func NewHub() *Hub {
	return &Hub{
		broadcast:  make(chan []byte),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		clients:    make(map[int]map[*Client]bool),
	}
}

// Run starts the hub
func (h *Hub) Run() {
	for {
		select {
		case client := <-h.register:
			h.mu.Lock()
			if _, ok := h.clients[client.ChatID]; !ok {
				h.clients[client.ChatID] = make(map[*Client]bool)
			}
			h.clients[client.ChatID][client] = true
			h.mu.Unlock()

		case client := <-h.unregister:
			h.mu.Lock()
			if clients, ok := h.clients[client.ChatID]; ok {
				if _, ok := clients[client]; ok {
					delete(clients, client)
					close(client.Send)
					if len(clients) == 0 {
						delete(h.clients, client.ChatID)
					}
				}
			}
			h.mu.Unlock()

		case message := <-h.broadcast:
			h.broadcastMessage(message)
		}
	}
}

// broadcastMessage sends a message to all connected clients
func (h *Hub) broadcastMessage(message []byte) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	for _, clients := range h.clients {
		for client := range clients {
			select {
			case client.Send <- message:
			default:
				close(client.Send)
				h.mu.Lock()
				delete(clients, client)
				h.mu.Unlock()
			}
		}
	}
}

// BroadcastToChat sends a message to all clients in a specific chat
func (h *Hub) BroadcastToChat(chatID int, message []byte) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	if clients, ok := h.clients[chatID]; ok {
		for client := range clients {
			select {
			case client.Send <- message:
			default:
				close(client.Send)
				delete(clients, client)
			}
		}
	}
}

// RegisterClient registers a new client with the hub
func (h *Hub) RegisterClient(client *Client) {
	h.register <- client
}

// UnregisterClient unregisters a client from the hub
func (h *Hub) UnregisterClient(client *Client) {
	h.unregister <- client
}

// WritePump pumps messages from the hub to the websocket connection
func (c *Client) WritePump() {
	defer func() {
		c.Conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.Send:
			if !ok {
				c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			if err := c.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
				logger.Error("Failed to send message to client %d: %v", c.UserID, err)
				return
			}
		}
	}
}

// ReadPump pumps messages from the websocket connection to the hub
func (c *Client) ReadPump() {
	defer func() {
		c.Hub.UnregisterClient(c)
		c.Conn.Close()
	}()

	for {
		_, _, err := c.Conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				logger.Error("WebSocket read error: %v", err)
			}
			break
		}
	}
}

================
File: interfaces/controllers/auth_controller.go
================
// interfaces/controllers/auth_controller.go
package controllers

import (
	"github.com/f1rstid/realtime-chat/application/usecase"
	"github.com/f1rstid/realtime-chat/common"
	"github.com/gofiber/fiber/v2"
)

// RegisterRequest represents the registration request payload
type RegisterRequest struct {
	Email    string `json:"email" example:"user@example.com" validate:"required,email"`
	Nickname string `json:"nickname" example:"홍길동" validate:"required,min=2,max=20"`
	Password string `json:"password" example:"password123" validate:"required,min=8"`
}

// LoginRequest represents the login request payload
type LoginRequest struct {
	Email    string `json:"email" example:"user@example.com" validate:"required,email"`
	Password string `json:"password" example:"password123" validate:"required"`
}

type AuthController struct {
	authUseCase *usecase.AuthUsecase
}

func NewAuthController(usecase *usecase.AuthUsecase) *AuthController {
	return &AuthController{
		authUseCase: usecase,
	}
}

// Register godoc
// @Summary      사용자 등록
// @Description  새로운 사용자를 등록하고 인증 토큰을 반환합니다
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        request body RegisterRequest true "등록 정보"
// @Success      201  {object}  common.RegisterResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      409  {object}  common.ErrEmailExists
// @Failure      409  {object}  common.ErrNicknameExists
// @Failure      500  {object}  common.ErrInternalServer
// @Router       /api/auth/register [post]
func (ac *AuthController) Register(c *fiber.Ctx) error {
	var input RegisterRequest
	if err := c.BodyParser(&input); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(common.InvalidRequest)
	}

	if input.Email == "" || input.Password == "" || input.Nickname == "" {
		return c.Status(fiber.StatusBadRequest).JSON(common.InvalidRequest)
	}

	registerInput := usecase.RegisterInput{
		Email:    input.Email,
		Password: input.Password,
		Nickname: input.Nickname,
	}

	authResponse, err := ac.authUseCase.Register(registerInput)
	if err != nil {
		switch err.Error() {
		case "email already exists":
			return c.Status(fiber.StatusConflict).JSON(common.EmailExists)
		case "nickname already exists":
			return c.Status(fiber.StatusConflict).JSON(common.NicknameExists)
		default:
			return c.Status(fiber.StatusInternalServerError).JSON(common.InternalServer)
		}
	}

	return c.Status(fiber.StatusCreated).JSON(common.BaseResponse{
		Success: true,
		Code:    common.StatusCreated,
		Data:    authResponse,
	})
}

// Login godoc
// @Summary      사용자 로그인
// @Description  이메일과 비밀번호로 로그인하고 인증 토큰을 반환합니다
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        request body LoginRequest true "로그인 정보"
// @Success      200  {object}  common.LoginResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      401  {object}  common.ErrInvalidAuth
// @Failure      500  {object}  common.ErrInternalServer
// @Router       /api/auth/login [post]
func (ac *AuthController) Login(c *fiber.Ctx) error {
	var input LoginRequest
	if err := c.BodyParser(&input); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(common.InvalidRequest)
	}

	if input.Email == "" || input.Password == "" {
		return c.Status(fiber.StatusBadRequest).JSON(common.InvalidRequest)
	}

	loginInput := usecase.LoginInput{
		Email:    input.Email,
		Password: input.Password,
	}

	authResponse, err := ac.authUseCase.Login(loginInput)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(common.InvalidAuth)
	}

	return c.Status(fiber.StatusOK).JSON(common.BaseResponse{
		Success: true,
		Code:    common.StatusSuccess,
		Data:    authResponse,
	})
}

================
File: interfaces/controllers/chat_controller.go
================
// interfaces/controllers/chat_controller.go
package controllers

import (
	"github.com/f1rstid/realtime-chat/application/usecase"
	"github.com/f1rstid/realtime-chat/interfaces"
	"github.com/gofiber/fiber/v2"
)

type CreatePrivateChatRequest struct {
	TargetId int `json:"targetId" example:"1"`
}

// CreateGroupChatRequest represents the request for creating a group chat
type CreateGroupChatRequest struct {
	Name    string `json:"name" example:"Team Chat" validate:"required"`
	UserIDs []int  `json:"userIds" example:"[1,2,3]" validate:"required"`
}

type ChatController struct {
	chatUseCase    *usecase.ChatUsecase
	messageUseCase *usecase.MessageUsecase
}

func NewChatController(
	chatUseCase *usecase.ChatUsecase,
	messageUseCase *usecase.MessageUsecase,
) *ChatController {
	return &ChatController{
		chatUseCase:    chatUseCase,
		messageUseCase: messageUseCase,
	}
}

// CreatePrivateChat godoc
// @Summary      1:1 채팅 생성
// @Description  두 사용자 간의 1:1 채팅을 생성합니다
// @Tags         Chat
// @Accept       json
// @Produce      json
// @Param        request body CreatePrivateChatRequest true "상대 사용자ID"
// @Success      201  {object}  common.ChatResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      500  {object}  common.ErrInternalServer
// @Security     Bearer
// @Router       /api/chats/private [post]
func (cc *ChatController) CreatePrivateChat(c *fiber.Ctx) error {
	var req CreatePrivateChatRequest
	if err := c.BodyParser(&req); err != nil {
		return interfaces.SendBadRequest(c, "잘못된 요청 형식입니다")
	}

	userID := c.Locals("userId").(int)

	chat, err := cc.chatUseCase.CreatePrivateChat(userID, req.TargetId)
	if err != nil {
		switch err.Error() {
		case "user1 not found", "user2 not found":
			return interfaces.SendNotFound(c, "사용자")
		default:
			return interfaces.SendInternalError(c)
		}
	}

	return interfaces.SendCreated(c, chat)
}

// CreateGroupChat godoc
// @Summary      그룹 채팅 생성
// @Description  그룹 채팅방을 생성합니다
// @Tags         Chat
// @Accept       json
// @Produce      json
// @Param        request body CreateGroupChatRequest true "채팅방 생성 정보"
// @Success      201  {object}  common.ChatResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      500  {object}  common.ErrInternalServer
// @Security     Bearer
// @Router       /api/chats/group [post]
func (cc *ChatController) CreateGroupChat(c *fiber.Ctx) error {
	var req CreateGroupChatRequest
	if err := c.BodyParser(&req); err != nil {
		return interfaces.SendBadRequest(c, "잘못된 요청 형식입니다")
	}

	if req.Name == "" {
		return interfaces.SendBadRequest(c, "채팅방 이름은 필수 항목입니다")
	}

	if len(req.UserIDs) < 2 {
		return interfaces.SendBadRequest(c, "그룹 채팅은 최소 2명 이상의 사용자가 필요합니다")
	}

	chat, err := cc.chatUseCase.CreateGroupChat(req.Name, req.UserIDs)
	if err != nil {
		switch err.Error() {
		case "user not found":
			return interfaces.SendNotFound(c, "사용자")
		default:
			return interfaces.SendInternalError(c)
		}
	}

	return interfaces.SendCreated(c, chat)
}

func (cc *ChatController) GetChats(c *fiber.Ctx) error {
	userID := c.Locals("userId").(int)

	chats, err := cc.chatUseCase.GetUserChats(userID)
	if err != nil {
		return interfaces.SendInternalError(c)
	}

	return interfaces.SendSuccess(c, chats)
}

================
File: interfaces/controllers/message_controller.go
================
package controllers

import (
	"github.com/f1rstid/realtime-chat/application/usecase"
	"github.com/f1rstid/realtime-chat/interfaces"
	"github.com/gofiber/fiber/v2"
	"log"
)

// SendMessageRequest represents the request for sending a message
type SendMessageRequest struct {
	ChatID  int    `json:"chatId" example:"1" validate:"required"`
	Content string `json:"content" example:"Hello, how are you?" validate:"required"`
}

// UpdateMessageRequest represents the request for updating a message
type UpdateMessageRequest struct {
	Content string `json:"content" example:"Updated message content" validate:"required"`
}

type MessageController struct {
	messageUseCase *usecase.MessageUsecase
}

func NewMessageController(messageUseCase *usecase.MessageUsecase) *MessageController {
	return &MessageController{
		messageUseCase: messageUseCase,
	}
}

// SendMessage godoc
// @Summary      메시지 전송
// @Description  채팅방에 새로운 메시지를 전송합니다
// @Tags         Message
// @Accept       json
// @Produce      json
// @Param        request body SendMessageRequest true "메시지 정보"
// @Success      201  {object}  common.MessageResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      500  {object}  common.ErrInternalServer
// @Security     Bearer
// @Router       /api/messages [post]
func (mc *MessageController) SendMessage(c *fiber.Ctx) error {
	var req SendMessageRequest
	if err := c.BodyParser(&req); err != nil {
		return interfaces.SendBadRequest(c, "잘못된 요청 형식입니다")
	}

	if req.Content == "" {
		return interfaces.SendBadRequest(c, "메시지 내용은 필수 항목입니다")
	}

	userID := c.Locals("userId").(int)

	message, err := mc.messageUseCase.SendMessage(req.ChatID, userID, req.Content)
	if err != nil {
		switch err.Error() {
		case "chat not found":
			return interfaces.SendNotFound(c, "채팅방")
		default:
			return interfaces.SendInternalError(c)
		}
	}

	return interfaces.SendCreated(c, message)
}

// UpdateMessage godoc
// @Summary      메시지 수정
// @Description  기존 메시지의 내용을 수정합니다
// @Tags         Message
// @Accept       json
// @Produce      json
// @Param        id   path      int  true  "메시지 ID"
// @Param        request body UpdateMessageRequest true "수정할 메시지 내용"
// @Success      200  {object}  common.MessageResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      403  {object}  common.ErrUnauthorizedMessage
// @Failure      500  {object}  common.ErrInternalServer
// @Security     Bearer
// @Router       /api/messages/{id} [put]
func (mc *MessageController) UpdateMessage(c *fiber.Ctx) error {
	messageID, err := c.ParamsInt("id")
	if err != nil {
		return interfaces.SendBadRequest(c, "잘못된 메시지 ID입니다")
	}

	var req UpdateMessageRequest
	if err := c.BodyParser(&req); err != nil {
		return interfaces.SendBadRequest(c, "잘못된 요청 형식입니다")
	}

	if req.Content == "" {
		return interfaces.SendBadRequest(c, "메시지 내용은 필수 항목입니다")
	}

	userID := c.Locals("userId").(int)

	message, err := mc.messageUseCase.UpdateMessage(messageID, userID, req.Content)
	if err != nil {
		switch err.Error() {
		case "message not found":
			return interfaces.SendNotFound(c, "메시지")
		case "unauthorized to update this message":
			return interfaces.SendForbidden(c)
		default:
			return interfaces.SendInternalError(c)
		}
	}

	return interfaces.SendSuccess(c, message)
}

// DeleteMessage godoc
// @Summary      메시지 삭제
// @Description  메시지를 삭제합니다
// @Tags         Message
// @Accept       json
// @Produce      json
// @Param        id   path      int  true  "메시지 ID"
// @Success      200  {object}  common.MessageResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      403  {object}  common.ErrUnauthorizedMessage
// @Failure      500  {object}  common.ErrInternalServer
// @Security     Bearer
// @Router       /api/messages/{id} [delete]
func (mc *MessageController) DeleteMessage(c *fiber.Ctx) error {
	messageID, err := c.ParamsInt("id")
	if err != nil {
		return interfaces.SendBadRequest(c, "잘못된 메시지 ID입니다")
	}

	userID := c.Locals("userId").(int)

	if err := mc.messageUseCase.DeleteMessage(messageID, userID); err != nil {
		switch err.Error() {
		case "message not found":
			return interfaces.SendNotFound(c, "메시지")
		case "unauthorized to delete this message":
			return interfaces.SendForbidden(c)
		default:
			return interfaces.SendInternalError(c)
		}
	}

	return interfaces.SendSuccess(c, "메시지가 삭제되었습니다")
}

// GetChatMessages godoc
// @Summary      채팅방 메시지 조회
// @Description  채팅방의 메시지를 페이지네이션하여 조회합니다. 한 번에 50개의 메시지를 가져오며, 무한 스크롤을 지원합니다.
// @Tags         Message
// @Accept       json
// @Produce      json
// @Param        chatId   path      int  true  "채팅방 ID"
// @Param        cursor   query     int  false "커서 (이전 페이지의 마지막 메시지 ID, 첫 페이지는 0 또는 생략)"
// @Success      200  {object}  common.MessageListResponse
// @Failure      400  {object}  common.ErrInvalidRequest
// @Failure      404  {object}  common.ErrChatNotFound
// @Failure      500  {object}  common.ErrInternalServer
// @Security     Bearer
// @Router       /api/chats/{chatId}/messages [get]
func (mc *MessageController) GetChatMessages(c *fiber.Ctx) error {
	chatId, err := c.ParamsInt("chatId")
	if err != nil {
		return interfaces.SendBadRequest(c, "잘못된 채팅방 ID입니다")
	}

	cursor := c.QueryInt("cursor", 0)

	messages, err := mc.messageUseCase.GetChatMessages(chatId, cursor)
	if err != nil {
		switch err.Error() {
		case "chat not found":
			return interfaces.SendNotFound(c, "채팅방")
		default:
			log.Println(err)
			return interfaces.SendInternalError(c)
		}
	}

	return interfaces.SendSuccess(c, messages)
}

================
File: interfaces/controllers/websocket_controller.go
================
// interfaces/controllers/websocket_controller.go
package controllers

import (
	"strconv"

	"github.com/f1rstid/realtime-chat/infrastructure/logger"
	"github.com/f1rstid/realtime-chat/infrastructure/websocket"
	"github.com/gofiber/fiber/v2"
	ws "github.com/gofiber/websocket/v2"
)

type WebSocketController struct {
	hub *websocket.Hub
}

func NewWebSocketController(hub *websocket.Hub) *WebSocketController {
	return &WebSocketController{
		hub: hub,
	}
}

// HandleWebSocket is a middleware for upgrading to websocket connections
func (wc *WebSocketController) HandleWebSocket(c *fiber.Ctx) error {
	if ws.IsWebSocketUpgrade(c) {
		c.Locals("allowed", true)
		c.Locals("userId", c.Locals("userId"))
		return c.Next()
	}
	return fiber.ErrUpgradeRequired
}

// WebSocket handles the WebSocket connection
func (wc *WebSocketController) WebSocket(c *ws.Conn) {
	// Get user ID from context (set by auth middleware)
	userID := c.Locals("userId")
	if userID == nil {
		c.Close()
		return
	}

	// Get chat ID from URL parameter
	chatIDStr := c.Params("chatId")
	if chatIDStr == "" {
		c.Close()
		return
	}

	chatID, err := strconv.Atoi(chatIDStr)
	if err != nil {
		logger.Error("Invalid chatId format: %v", err)
		c.Close()
		return
	}

	userIDInt, ok := userID.(int)
	if !ok {
		logger.Error("Invalid userId type: %T", userID)
		c.Close()
		return
	}

	logger.Info("New WebSocket connection - UserID: %d, ChatID: %d", userIDInt, chatID)

	// Create new client
	client := &websocket.Client{
		Hub:    wc.hub,
		Conn:   c,
		Send:   make(chan []byte, 256),
		UserID: userIDInt,
		ChatID: chatID,
	}

	client.Hub.RegisterClient(client)

	// Setup ping handler to maintain connection
	c.SetCloseHandler(func(code int, text string) error {
		logger.Info("WebSocket connection closed - UserID: %d, ChatID: %d", userIDInt, chatID)
		return nil
	})

	// Start client message pumps
	go client.WritePump()
	client.ReadPump()
}

================
File: interfaces/middlewares/auth_middleware.go
================
package middlewares

import (
	"strings"

	"github.com/f1rstid/realtime-chat/domain/services"
	"github.com/f1rstid/realtime-chat/interfaces"
	"github.com/gofiber/fiber/v2"
)

func AuthMiddleware(authService services.AuthService) fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Get token from header
		authHeader := c.Get("authorization")

		if authHeader == "" {
			return interfaces.SendUnauthorized(c)
		}

		// Check Bearer format
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			return interfaces.SendUnauthorized(c)
		}

		// Validate token
		claims, err := authService.ValidateToken(parts[1])
		if err != nil {
			return interfaces.SendUnauthorized(c)
		}

		// Set claims in context
		c.Locals("userId", claims.UserID)
		c.Locals("userEmail", claims.Email)
		c.Locals("userNickname", claims.Nickname)

		return c.Next()
	}
}

================
File: interfaces/middlewares/error_handler.go
================
package middlewares

import (
	"github.com/f1rstid/realtime-chat/infrastructure/logger"
	"github.com/gofiber/fiber/v2"
)

func ErrorHandler() fiber.ErrorHandler {
	return func(c *fiber.Ctx, err error) error {
		// 에러 코드 설정
		code := fiber.StatusInternalServerError
		if e, ok := err.(*fiber.Error); ok {
			code = e.Code
		}

		// 에러 로깅
		logger.Error("Request failed - Method: %s, Path: %s, Error: %v",
			c.Method(), c.Path(), err)

		// 클라이언트에게 에러 응답
		return c.Status(code).JSON(fiber.Map{
			"success": false,
			"error":   err.Error(),
			"code":    code,
		})
	}
}

================
File: interfaces/middlewares/request_logger.go
================
package middlewares

import (
	"time"

	"github.com/f1rstid/realtime-chat/infrastructure/logger"
	"github.com/gofiber/fiber/v2"
)

func RequestLogger() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// 요청 시작 시간 기록
		start := time.Now()

		// 다음 핸들러 실행
		err := c.Next()

		// 요청 처리 시간 계산
		duration := time.Since(start)

		// 요청 정보 로깅
		logger.LogRequest(
			c.Method(),
			c.Path(),
			c.IP(),
			c.Get("User-Agent"),
			c.Response().StatusCode(),
			duration,
		)

		// 에러가 발생한 경우 에러 로깅
		if err != nil {
			logger.LogError(err, c.Method(), c.Path())
		}

		return err
	}
}

================
File: interfaces/middlewares/websocket_middleware.go
================
// interfaces/middlewares/websocket_middleware.go
package middlewares

import (
	"log"
	"strings"

	"github.com/f1rstid/realtime-chat/domain/services"
	"github.com/gofiber/fiber/v2"
)

func WebSocketAuthMiddleware(authService services.AuthService) fiber.Handler {
	return func(c *fiber.Ctx) error {
		log.Printf("WebSocket auth middleware - Path: %s", c.Path())

		// Get token from query parameter or header
		var token string

		// First try to get from query parameter
		token = c.Query("token")
		log.Printf("Token from query: %s", maskToken(token))

		// If not in query, try to get from header
		if token == "" {
			auth := c.Get("Authorization")
			log.Printf("Authorization header: %s", maskToken(auth))
			if auth != "" && strings.HasPrefix(auth, "Bearer ") {
				token = auth[7:] // Remove "Bearer " prefix
			}
		}

		if token == "" {
			log.Println("WebSocket auth failed: no token provided")
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		// Validate token
		claims, err := authService.ValidateToken(token)
		if err != nil {
			log.Printf("WebSocket auth failed: invalid token - %v", err)
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Invalid token",
			})
		}

		log.Printf("WebSocket auth successful - UserID: %d", claims.UserID)

		// Store user information in context
		c.Locals("userId", claims.UserID)
		c.Locals("userEmail", claims.Email)
		c.Locals("userNickname", claims.Nickname)

		return c.Next()
	}
}

// maskToken masks the token for logging purposes
func maskToken(token string) string {
	if len(token) > 10 {
		return token[:4] + "..." + token[len(token)-4:]
	}
	return "[empty]"
}

================
File: interfaces/repositories/chat_repository.go
================
package repositories

import (
	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/f1rstid/realtime-chat/domain/repositories"
	"github.com/jmoiron/sqlx"
)

type ChatRepository struct {
	DB *sqlx.DB
}

func NewChatRepository(db *sqlx.DB) repositories.ChatRepository {
	return &ChatRepository{DB: db}
}

func (r *ChatRepository) Create(chat *models.Chat) error {
	query := `INSERT INTO chats (name) VALUES ($1) RETURNING id`
	row := r.DB.QueryRow(query, chat.Name)
	return row.Scan(&chat.ID)
}

func (r *ChatRepository) FindById(id int) (*models.Chat, error) {
	chat := models.Chat{}
	query := `SELECT * FROM chats WHERE id = $1`
	err := r.DB.Get(&chat, query, id)

	if err != nil {
		return nil, err
	}
	return &chat, nil
}

func (r *ChatRepository) Update(chat *models.Chat) error {
	query := `UPDATE chats SET name = $1 WHERE id = $2`
	_, err := r.DB.Exec(query, chat.Name, chat.ID)
	return err
}

func (r *ChatRepository) Delete(id int) error {
	query := `DELETE FROM chats WHERE id = $1`
	_, err := r.DB.Exec(query, id)
	return err
}

func (r *ChatRepository) AddUserToChat(chatID, userID int) error {
	query := `INSERT INTO chat_groups (chatId, userId) VALUES ($1, $2)`
	_, err := r.DB.Exec(query, chatID, userID)
	return err
}

func (r *ChatRepository) RemoveUserFromChat(chatID, userID int) error {
	query := `DELETE FROM chatGroups WHERE chatId = $1 AND userId = $2`
	_, err := r.DB.Exec(query, chatID, userID)
	return err
}

func (r *ChatRepository) GetChatUsers(chatID int) ([]models.User, error) {
	var users []models.User
	query := `
		SELECT u.* 
		FROM users u
		JOIN chatGroups cg ON u.id = cg.userId
		WHERE cg.chatId = $1
	`
	err := r.DB.Select(&users, query, chatID)
	return users, err
}

func (r *ChatRepository) GetUserChats(userID int) ([]models.Chat, error) {
	var chats []models.Chat
	query := `
		SELECT c.* 
		FROM chats c
		JOIN chatGroups cg ON c.id = cg.chatId
		WHERE cg.userId = $1
	`
	err := r.DB.Select(&chats, query, userID)
	return chats, err
}

================
File: interfaces/repositories/message_repository.go
================
package repositories

import (
	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/f1rstid/realtime-chat/domain/repositories"
	"github.com/jmoiron/sqlx"
)

type MessageRepository struct {
	DB *sqlx.DB
}

func NewMessageRepository(db *sqlx.DB) repositories.MessageRepository {
	return &MessageRepository{DB: db}
}

func (r *MessageRepository) Create(message *models.Message) error {
	query := `
		INSERT INTO messages (chatId, senderId, content, createdAt, updatedAt)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`
	row := r.DB.QueryRow(
		query,
		message.ChatId,
		message.SenderId,
		message.Content,
		message.CreatedAt,
		message.UpdatedAt,
	)
	err := row.Scan(&message.ID)
	if err != nil {
		return err
	}

	// Fetch sender nickname
	query = `SELECT nickname FROM users WHERE id = $1`
	err = r.DB.Get(&message.SenderNickname, query, message.SenderId)
	return err
}

func (r *MessageRepository) FindById(id int) (*models.Message, error) {
	message := models.Message{}
	query := `
		SELECT m.*, u.nickname as senderNickname, m.id as id
		FROM messages m
		JOIN users u ON m.senderId = u.id
		WHERE m.id = $1
	`
	err := r.DB.Get(&message, query, id)
	if err != nil {
		return nil, err
	}
	return &message, nil
}

func (r *MessageRepository) Update(message *models.Message) error {
	// Update message
	query := `
		UPDATE messages 
		SET content = $1, updatedAt = $2
		WHERE id = $3
	`
	_, err := r.DB.Exec(query, message.Content, message.UpdatedAt, message.ID)
	if err != nil {
		return err
	}

	// Fetch sender nickname
	query = `SELECT nickname FROM users WHERE id = $1`
	return r.DB.Get(&message.SenderNickname, query, message.SenderId)
}

func (r *MessageRepository) Delete(id int) error {
	query := `DELETE FROM messages WHERE id = $1`
	_, err := r.DB.Exec(query, id)
	return err
}

func (r *MessageRepository) FindByChatId(chatId int, cursor int, limit int) ([]models.Message, error) {
	var messages []models.Message
	var query string
	var err error

	if cursor == 0 {
		// First page: get the most recent messages
		query = `
			SELECT m.*, u.nickname as senderNickname, m.id as id 
			FROM messages m
			JOIN users u ON m.senderId = u.id
			WHERE m.chatId = $1
			ORDER BY m.id DESC
			LIMIT $2
		`
		err = r.DB.Select(&messages, query, chatId, limit)
	} else {
		// Subsequent pages: get messages before the cursor
		query = `
			SELECT m.*, u.nickname as senderNickname, m.id as id 
			FROM messages m
			JOIN users u ON m.senderId = u.id
			WHERE m.chatId = $1 AND m.id < $2
			ORDER BY m.id DESC
			LIMIT $3
		`
		err = r.DB.Select(&messages, query, chatId, cursor, limit)
	}

	return messages, err
}

func (r *MessageRepository) GetLastMessageId(chatId int) (int, error) {
	var lastId int
	query := `SELECT COALESCE(MAX(id), 0) FROM messages WHERE chatId = $1`
	err := r.DB.Get(&lastId, query, chatId)
	return lastId, err
}

================
File: interfaces/repositories/user_repository.go
================
package repositories

import (
	"github.com/f1rstid/realtime-chat/domain/models"
	"github.com/f1rstid/realtime-chat/domain/repositories"
	"github.com/jmoiron/sqlx"
)

type UserRepository struct {
	DB *sqlx.DB
}

func NewUserRepository(db *sqlx.DB) repositories.UserRepository {
	return &UserRepository{DB: db}
}

func (r *UserRepository) Create(user *models.User) (*models.User, error) {
	query := `INSERT INTO users (email, nickname, password) VALUES ($1, $2, $3) RETURNING id`
	row := r.DB.QueryRow(query, user.Email, user.Nickname, user.Password)
	err := row.Scan(&user.ID)
	if err != nil {
		return nil, err
	}
	return user, nil
}

func (r *UserRepository) FindByID(id int) (*models.User, error) {
	user := models.User{}
	query := `SELECT * FROM users WHERE id = $1`
	err := r.DB.Get(&user, query, id)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *UserRepository) FindByEmail(email string) (*models.User, error) {
	user := models.User{}
	query := `SELECT * FROM users WHERE email = $1`
	err := r.DB.Get(&user, query, email)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *UserRepository) FindByNickname(nickname string) (*models.User, error) {
	user := models.User{}
	query := `SELECT * FROM users WHERE nickname = $1`
	err := r.DB.Get(&user, query, nickname)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *UserRepository) Update(user *models.User) error {
	query := `UPDATE users SET email = $1, nickname = $2, password = $3 WHERE id = $4`
	_, err := r.DB.Exec(query, user.Email, user.Nickname, user.Password, user.ID)
	return err
}

// Add the missing Delete method
func (r *UserRepository) Delete(id int) error {
	query := `DELETE FROM users WHERE id = $1`
	_, err := r.DB.Exec(query, id)
	return err
}

================
File: interfaces/routers/router.go
================
package routers

import (
	"github.com/f1rstid/realtime-chat/application/usecase"
	"github.com/f1rstid/realtime-chat/config"
	"github.com/f1rstid/realtime-chat/domain/services"
	"github.com/f1rstid/realtime-chat/infrastructure/sqlite"
	"github.com/f1rstid/realtime-chat/infrastructure/websocket"
	"github.com/f1rstid/realtime-chat/interfaces/controllers"
	"github.com/f1rstid/realtime-chat/interfaces/middlewares"
	"github.com/f1rstid/realtime-chat/interfaces/repositories"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/swagger"
	ws "github.com/gofiber/websocket/v2"
)

func SetRoutes(app *fiber.App, config *config.Config) {
	// Initialize WebSocket hub
	wsHub := websocket.NewHub()
	go wsHub.Run()

	// Initialize repositories
	userRepo := repositories.NewUserRepository(sqlite.DB)
	chatRepo := repositories.NewChatRepository(sqlite.DB)
	messageRepo := repositories.NewMessageRepository(sqlite.DB)

	// Initialize services
	authService := services.NewAuthService(config.JWTSecret)

	// Initialize usecases
	authUseCase := usecase.NewAuthUsecase(userRepo, authService)
	chatUseCase := usecase.NewChatUsecase(chatRepo, messageRepo, userRepo)
	messageUseCase := usecase.NewMessageUsecase(messageRepo, chatRepo, wsHub)

	// Initialize controllers
	authController := controllers.NewAuthController(authUseCase)
	chatController := controllers.NewChatController(chatUseCase, messageUseCase)
	messageController := controllers.NewMessageController(messageUseCase)
	wsController := controllers.NewWebSocketController(wsHub)

	// Swagger
	app.Get("/swagger/*", swagger.HandlerDefault)

	// Auth routes
	auth := app.Group("/api/auth")
	auth.Post("/register", authController.Register)
	auth.Post("/login", authController.Login)

	// Protected routes
	api := app.Group("/api", middlewares.AuthMiddleware(authService))

	// Chat routes
	chats := api.Group("/chats")
	chats.Post("/private", chatController.CreatePrivateChat)
	chats.Post("/group", chatController.CreateGroupChat)
	api.Get("/chats/:chatId/messages", messageController.GetChatMessages)

	// Message routes
	messages := api.Group("/messages")
	messages.Post("/", messageController.SendMessage)
	messages.Put("/:id", messageController.UpdateMessage)
	messages.Delete("/:id", messageController.DeleteMessage)

	// WebSocket routes with authentication
	app.Use("/ws", middlewares.WebSocketAuthMiddleware(authService))
	app.Use("/ws/:chatId", wsController.HandleWebSocket)
	app.Get("/ws/:chatId", ws.New(wsController.WebSocket))
}

================
File: interfaces/errors.go
================
package interfaces

// Error codes
const (
	// Message codes (1xxx)
	MessageSendCode   = 1000
	MessageUpdateCode = 1001
	MessageDeleteCode = 1002

	// Success codes (2xxx)
	SuccessCode = 2000
	CreatedCode = 2001
	UpdatedCode = 2002
	DeletedCode = 2003

	// Client error codes (4xxx)
	InvalidRequestError     = 4000
	UnauthorizedError       = 4001
	ForbiddenError          = 4002
	NotFoundError           = 4003
	EmailExistsError        = 4004
	NicknameExistsError     = 4005
	InvalidCredentialsError = 4006
	ValidationError         = 4007
	InvalidTokenError       = 4008

	// Server error codes (5xxx)
	InternalServerError = 5000
	DatabaseError       = 5001
)

type AppError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

var errorMap = map[int]AppError{
	// Success
	SuccessCode: {
		Code:    SuccessCode,
		Message: "Success",
		Status:  200,
	},
	CreatedCode: {
		Code:    CreatedCode,
		Message: "Created successfully",
		Status:  201,
	},

	// Client errors
	InvalidRequestError: {
		Code:    InvalidRequestError,
		Message: "Invalid request",
		Status:  400,
	},
	UnauthorizedError: {
		Code:    UnauthorizedError,
		Message: "Unauthorized",
		Status:  401,
	},
	ForbiddenError: {
		Code:    ForbiddenError,
		Message: "Forbidden",
		Status:  403,
	},
	NotFoundError: {
		Code:    NotFoundError,
		Message: "Resource not found",
		Status:  404,
	},
	EmailExistsError: {
		Code:    EmailExistsError,
		Message: "Email already exists",
		Status:  400,
	},
	NicknameExistsError: {
		Code:    NicknameExistsError,
		Message: "Nickname already exists",
		Status:  400,
	},
	InvalidCredentialsError: {
		Code:    InvalidCredentialsError,
		Message: "Invalid email or password",
		Status:  401,
	},
	ValidationError: {
		Code:    ValidationError,
		Message: "Validation failed",
		Status:  400,
	},
	InvalidTokenError: {
		Code:    InvalidTokenError,
		Message: "Invalid or expired token",
		Status:  401,
	},

	// Server errors
	InternalServerError: {
		Code:    InternalServerError,
		Message: "Internal server error",
		Status:  500,
	},
	DatabaseError: {
		Code:    DatabaseError,
		Message: "Database error",
		Status:  500,
	},
}

================
File: interfaces/response.go
================
// interfaces/response.go
package interfaces

import (
	"github.com/gofiber/fiber/v2"
)

// Response 구조체는 공통 응답 구조를 사용합니다.
type Response struct {
	Success bool        `json:"success" example:"true"`
	Code    int         `json:"code" example:"2000"`
	Data    interface{} `json:"data"`
}

// Data models are moved to the common package, so you can remove redundant definitions here.

const (
	// Success codes (2xxx)
	StatusSuccess = 2000
	StatusCreated = 2001
	StatusUpdated = 2002
	StatusDeleted = 2003

	// Client error codes (4xxx)
	StatusBadRequest         = 4000
	StatusUnauthorized       = 4001
	StatusForbidden          = 4002
	StatusNotFound           = 4003
	StatusEmailExists        = 4004
	StatusNicknameExists     = 4005
	StatusInvalidCredentials = 4006
	StatusValidationError    = 4007
	StatusInvalidToken       = 4008

	// Server error codes (5xxx)
	StatusInternalError = 5000
	StatusDBError       = 5001
)

// Response helpers
func SendResponse(c *fiber.Ctx, httpStatus, code int, success bool, data interface{}) error {
	return c.Status(httpStatus).JSON(Response{
		Code:    code,
		Success: success,
		Data:    data,
	})
}

func SendSuccess(c *fiber.Ctx, data interface{}) error {
	return SendResponse(c, fiber.StatusOK, StatusSuccess, true, data)
}

func SendCreated(c *fiber.Ctx, data interface{}) error {
	return SendResponse(c, fiber.StatusCreated, StatusCreated, true, data)
}

func SendUpdated(c *fiber.Ctx, data interface{}) error {
	return SendResponse(c, fiber.StatusOK, StatusUpdated, true, data)
}

func SendDeleted(c *fiber.Ctx, data interface{}) error {
	return SendResponse(c, fiber.StatusOK, StatusDeleted, true, data)
}

func SendError(c *fiber.Ctx, httpStatus, code int, message string) error {
	return SendResponse(c, httpStatus, code, false, message)
}

// Error helpers
func SendBadRequest(c *fiber.Ctx, message string) error {
	return SendError(c, fiber.StatusBadRequest, StatusBadRequest, message)
}

func SendUnauthorized(c *fiber.Ctx) error {
	return SendError(c, fiber.StatusUnauthorized, StatusUnauthorized, "인증되지 않은 접근입니다")
}

func SendForbidden(c *fiber.Ctx) error {
	return SendError(c, fiber.StatusForbidden, StatusForbidden, "접근 권한이 없습니다")
}

func SendNotFound(c *fiber.Ctx, resource string) error {
	return SendError(c, fiber.StatusNotFound, StatusNotFound, resource+"를 찾을 수 없습니다")
}

func SendEmailExists(c *fiber.Ctx) error {
	return SendError(c, fiber.StatusConflict, StatusEmailExists, "이미 사용중인 이메일입니다")
}

func SendInternalError(c *fiber.Ctx) error {
	return SendError(c, fiber.StatusInternalServerError, StatusInternalError, "내부 서버 오류가 발생했습니다")
}

================
File: .gitignore
================
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib
*.db

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

================
File: Dockerfile
================
# Builder stage
FROM golang:1.21-alpine AS builder

# Install required packages and swag CLI
RUN apk add --no-cache gcc musl-dev sqlite-dev git && \
    go install github.com/swaggo/swag/cmd/swag@latest

# Set working directory
WORKDIR /app

# Copy go mod and sum files
COPY go.mod go.sum ./

# Download dependencies and verify
RUN go mod download && \
    go mod verify

# Copy source code
COPY . .

# Generate Swagger documentation
RUN swag init

# Build the application
RUN CGO_ENABLED=1 GOOS=linux go build -o main .

# Final stage
FROM alpine:latest

# Install required runtime packages
RUN apk add --no-cache sqlite-libs ca-certificates tzdata

# Create non-root user
RUN adduser -D -g '' appuser

# Create necessary directories and set permissions
RUN mkdir -p /app/logs /app/docs /app/data && \
    chown -R appuser:appuser /app

# Set working directory
WORKDIR /app

# Copy binary and swagger docs from builder
COPY --from=builder /app/main .
COPY --from=builder /app/docs ./docs

# Create volume mount points
VOLUME ["/app/data"]

# Set ownership
RUN chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose ports
EXPOSE 5050

# Set environment variables
ENV GO_ENV=production
ENV SERVER_PORT=5050
ENV SERVER_URL=0.0.0.0
ENV DATABASE_DSN=/app/data/sqlite.db

# Command to run the application
CMD ["./main"]

================
File: go.mod
================
module github.com/f1rstid/realtime-chat

go 1.21

require (
	github.com/gofiber/fiber/v2 v2.52.5
	github.com/gofiber/swagger v1.1.0
	github.com/gofiber/websocket/v2 v2.2.1
	github.com/golang-jwt/jwt/v4 v4.5.1
	github.com/jmoiron/sqlx v1.4.0
	github.com/joho/godotenv v1.5.1
	github.com/mattn/go-sqlite3 v1.14.24
	github.com/swaggo/swag v1.16.4
	golang.org/x/crypto v0.29.0
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/andybalholm/brotli v1.1.1 // indirect
	github.com/fasthttp/websocket v1.5.3 // indirect
	github.com/go-openapi/jsonpointer v0.21.0 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/klauspost/compress v1.17.11 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/savsgio/gotils v0.0.0-20230208104028-c358bd845dee // indirect
	github.com/swaggo/files/v2 v2.0.1 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasthttp v1.57.0 // indirect
	github.com/valyala/tcplisten v1.0.0 // indirect
	golang.org/x/sys v0.27.0 // indirect
	golang.org/x/tools v0.13.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: go.sum
================
filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=
filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=
github.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=
github.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=
github.com/andybalholm/brotli v1.1.1 h1:PR2pgnyFznKEugtsUo0xLdDop5SKXd5Qf5ysW+7XdTA=
github.com/andybalholm/brotli v1.1.1/go.mod h1:05ib4cKhjx3OQYUY22hTVd34Bc8upXjOLL2rKwwZBoA=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/fasthttp/websocket v1.5.3 h1:TPpQuLwJYfd4LJPXvHDYPMFWbLjsT91n3GpWtCQtdek=
github.com/fasthttp/websocket v1.5.3/go.mod h1:46gg/UBmTU1kUaTcwQXpUxtRwG2PvIZYeA8oL6vF3Fs=
github.com/go-openapi/jsonpointer v0.21.0 h1:YgdVicSA9vH5RiHs9TZW5oyafXZFc6+2Vc1rr/O9oNQ=
github.com/go-openapi/jsonpointer v0.21.0/go.mod h1:IUyH9l/+uyhIYQ/PXVA41Rexl+kOkAPDdXEYns6fzUY=
github.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=
github.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=
github.com/go-openapi/spec v0.21.0 h1:LTVzPc3p/RzRnkQqLRndbAzjY0d0BCL72A6j3CdL9ZY=
github.com/go-openapi/spec v0.21.0/go.mod h1:78u6VdPw81XU44qEWGhtr982gJ5BWg2c0I5XwVMotYk=
github.com/go-openapi/swag v0.23.0 h1:vsEVJDUo2hPJ2tu0/Xc+4noaxyEffXNIs3cOULZ+GrE=
github.com/go-openapi/swag v0.23.0/go.mod h1:esZ8ITTYEsH1V2trKHjAN8Ai7xHb8RV+YSZ577vPjgQ=
github.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=
github.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=
github.com/gofiber/fiber/v2 v2.52.5 h1:tWoP1MJQjGEe4GB5TUGOi7P2E0ZMMRx5ZTG4rT+yGMo=
github.com/gofiber/fiber/v2 v2.52.5/go.mod h1:KEOE+cXMhXG0zHc9d8+E38hoX+ZN7bhOtgeF2oT6jrQ=
github.com/gofiber/swagger v1.1.0 h1:ff3rg1fB+Rp5JN/N8jfxTiZtMKe/9tB9QDc79fPiJKQ=
github.com/gofiber/swagger v1.1.0/go.mod h1:pRZL0Np35sd+lTODTE5The0G+TMHfNY+oC4hM2/i5m8=
github.com/gofiber/websocket/v2 v2.2.1 h1:C9cjxvloojayOp9AovmpQrk8VqvVnT8Oao3+IUygH7w=
github.com/gofiber/websocket/v2 v2.2.1/go.mod h1:Ao/+nyNnX5u/hIFPuHl28a+NIkrqK7PRimyKaj4JxVU=
github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jmoiron/sqlx v1.4.0 h1:1PLqN7S1UYp5t4SrVVnt4nUVNemrDAtxlulVe+Qgm3o=
github.com/jmoiron/sqlx v1.4.0/go.mod h1:ZrZ7UsYB/weZdl2Bxg6jCRO9c3YHl8r3ahlKmRT4JLY=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
github.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mattn/go-sqlite3 v1.14.22/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/mattn/go-sqlite3 v1.14.24 h1:tpSp2G2KyMnnQu99ngJ47EIkWVmliIizyZBfPrBWDRM=
github.com/mattn/go-sqlite3 v1.14.24/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=
github.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=
github.com/savsgio/gotils v0.0.0-20230208104028-c358bd845dee h1:8Iv5m6xEo1NR1AvpV+7XmhI4r39LGNzwUL4YpMuL5vk=
github.com/savsgio/gotils v0.0.0-20230208104028-c358bd845dee/go.mod h1:qwtSXrKuJh/zsFQ12yEE89xfCrGKK63Rr7ctU/uCo4g=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/swaggo/files/v2 v2.0.1 h1:XCVJO/i/VosCDsJu1YLpdejGsGnBE9deRMpjN4pJLHk=
github.com/swaggo/files/v2 v2.0.1/go.mod h1:24kk2Y9NYEJ5lHuCra6iVwkMjIekMCaFq/0JQj66kyM=
github.com/swaggo/swag v1.16.4 h1:clWJtd9LStiG3VeijiCfOVODP6VpHtKdQy9ELFG3s1A=
github.com/swaggo/swag v1.16.4/go.mod h1:VBsHJRsDvfYvqoiMKnsdwhNV9LEMHgEDZcyVYX0sxPg=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasthttp v1.57.0 h1:Xw8SjWGEP/+wAAgyy5XTvgrWlOD1+TxbbvNADYCm1Tg=
github.com/valyala/fasthttp v1.57.0/go.mod h1:h6ZBaPRlzpZ6O3H5t2gEk1Qi33+TmLvfwgLLp0t9CpE=
github.com/valyala/tcplisten v1.0.0 h1:rBHj/Xf+E1tRGZyWIWwJDiRY0zc1Js+CV5DqwacVSA8=
github.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=
github.com/xyproto/randomstring v1.0.5 h1:YtlWPoRdgMu3NZtP45drfy1GKoojuR7hmRcnhZqKjWU=
github.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=
golang.org/x/crypto v0.29.0 h1:L5SG1JTTXupVV3n6sUqMTeWbjAyfPwoda2DLX8J8FrQ=
golang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=
golang.org/x/mod v0.12.0 h1:rmsUpXtvNzj340zd98LZ4KntptpfRHwpFOHG188oHXc=
golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=
golang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/tools v0.13.0 h1:Iey4qkscZuv0VvIt8E0neZjtPVQFSc870HQ448QgEmQ=
golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

================
File: main.go
================
package main

import (
	"github.com/f1rstid/realtime-chat/docs"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"

	"github.com/f1rstid/realtime-chat/config"
	_ "github.com/f1rstid/realtime-chat/docs"
	"github.com/f1rstid/realtime-chat/infrastructure/logger"
	"github.com/f1rstid/realtime-chat/infrastructure/sqlite"
	"github.com/f1rstid/realtime-chat/interfaces/middlewares"
	"github.com/f1rstid/realtime-chat/interfaces/routers"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/swagger"
)

// @title           Realtime Chat API
// @version         1.0
// @description     실시간 채팅을 위한 RESTful API 서버입니다.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:5050
// @BasePath  /

// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description 'Bearer ' 접두사와 함께 JWT 토큰을 입력하세요. 예시: "Bearer eyJhbGciOi..."

// @Security Bearer
func main() {
	// 설정 로드
	config, err := config.LoadConfig()
	if err != nil {
		logger.Error("Failed to load config: %v", err)
		log.Fatal(err)
	}

	// 데이터베이스 디렉토리 확인 및 생성
	dbDir := filepath.Dir(config.Database.DSN)
	if err := os.MkdirAll(dbDir, 0755); err != nil {
		logger.Error("Failed to create database directory: %v", err)
		log.Fatal(err)
	}

	// 데이터베이스 초기화
	if err := sqlite.InitDB(config.Database.DSN); err != nil {
		logger.Error("Failed to initialize database: %v", err)
		log.Fatal(err)
	}

	// 데이터베이스 마이그레이션
	if err := sqlite.Migrate(); err != nil {
		logger.Error("Failed to migrate database: %v", err)
		log.Fatal(err)
	}
	defer sqlite.CloseDB()

	// Fiber 앱 생성
	app := fiber.New(fiber.Config{
		ErrorHandler: middlewares.ErrorHandler(),
	})

	// 미들웨어 설정
	app.Use(recover.New())
	app.Use(cors.New(cors.Config{
		AllowOrigins:  "*",
		AllowHeaders:  "*",
		AllowMethods:  "*",
		ExposeHeaders: "*",
	}))
	app.Use(middlewares.RequestLogger())

	docs.SwaggerInfo.Host = config.ServerURL + ":" + config.ServerPort

	// Swagger 설정
	app.Get("/swagger/*", swagger.New(swagger.Config{
		URL:         "/swagger/doc.json",
		DeepLinking: true,
	}))

	// 라우터 설정
	routers.SetRoutes(app, config)

	// 서버 시작
	go func() {
		logger.Info("Server is starting on port %s", config.ServerPort)
		logger.Info("Swagger documentation is available at http://localhost:%s/swagger/", config.ServerPort)
		if err := app.Listen(":" + config.ServerPort); err != nil {
			logger.Error("Server failed to start: %v", err)
			log.Fatal(err)
		}
	}()

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Info("Shutting down server...")
	if err := app.Shutdown(); err != nil {
		logger.Error("Failed to shutdown server: %v", err)
		log.Fatal(err)
	}
}

================
File: README.md
================
# realtime-chat
